/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.28 from the
 * contents of B.xs. Do not edit this file, edit B.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "B.xs"
/*	B.xs
 *
 *	Copyright (c) 1996 Malcolm Beattie
 *
 *	You may distribute under the terms of either the GNU General Public
 *	License or the Artistic License, as specified in the README file.
 *
 */

#define PERL_NO_GET_CONTEXT
#define PERL_EXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef PerlIO
typedef PerlIO * InputStream;
#else
typedef FILE * InputStream;
#endif


static const char* const svclassnames[] = {
    "B::NULL",
#if PERL_VERSION < 19
    "B::BIND",
#endif
    "B::IV",
    "B::NV",
#if PERL_VERSION <= 10
    "B::RV",
#endif
    "B::PV",
#if PERL_VERSION >= 19
    "B::INVLIST",
#endif
    "B::PVIV",
    "B::PVNV",
    "B::PVMG",
#if PERL_VERSION >= 11
    "B::REGEXP",
#endif
    "B::GV",
    "B::PVLV",
    "B::AV",
    "B::HV",
    "B::CV",
    "B::FM",
    "B::IO",
};

typedef enum {
    OPc_NULL,	/* 0 */
    OPc_BASEOP,	/* 1 */
    OPc_UNOP,	/* 2 */
    OPc_BINOP,	/* 3 */
    OPc_LOGOP,	/* 4 */
    OPc_LISTOP,	/* 5 */
    OPc_PMOP,	/* 6 */
    OPc_SVOP,	/* 7 */
    OPc_PADOP,	/* 8 */
    OPc_PVOP,	/* 9 */
    OPc_LOOP,	/* 10 */
    OPc_COP,	/* 11 */
    OPc_METHOP,	/* 12 */
    OPc_UNOP_AUX /* 13 */
} opclass;

static const char* const opclassnames[] = {
    "B::NULL",
    "B::OP",
    "B::UNOP",
    "B::BINOP",
    "B::LOGOP",
    "B::LISTOP",
    "B::PMOP",
    "B::SVOP",
    "B::PADOP",
    "B::PVOP",
    "B::LOOP",
    "B::COP",
    "B::METHOP",
    "B::UNOP_AUX"
};

static const size_t opsizes[] = {
    0,	
    sizeof(OP),
    sizeof(UNOP),
    sizeof(BINOP),
    sizeof(LOGOP),
    sizeof(LISTOP),
    sizeof(PMOP),
    sizeof(SVOP),
    sizeof(PADOP),
    sizeof(PVOP),
    sizeof(LOOP),
    sizeof(COP),
    sizeof(METHOP),
    sizeof(UNOP_AUX),
};

#define MY_CXT_KEY "B::_guts" XS_VERSION

typedef struct {
    SV *	x_specialsv_list[7];
    int		x_walkoptree_debug;	/* Flag for walkoptree debug hook */
} my_cxt_t;

START_MY_CXT

#define walkoptree_debug	(MY_CXT.x_walkoptree_debug)
#define specialsv_list		(MY_CXT.x_specialsv_list)


static void B_init_my_cxt(pTHX_ my_cxt_t * cxt) {
    cxt->x_specialsv_list[0] = Nullsv;
    cxt->x_specialsv_list[1] = &PL_sv_undef;
    cxt->x_specialsv_list[2] = &PL_sv_yes;
    cxt->x_specialsv_list[3] = &PL_sv_no;
    cxt->x_specialsv_list[4] = (SV *) pWARN_ALL;
    cxt->x_specialsv_list[5] = (SV *) pWARN_NONE;
    cxt->x_specialsv_list[6] = (SV *) pWARN_STD;
}

static opclass
cc_opclass(pTHX_ const OP *o)
{
    bool custom = 0;

    if (!o)
	return OPc_NULL;

    if (o->op_type == 0) {
	if (o->op_targ == OP_NEXTSTATE || o->op_targ == OP_DBSTATE)
	    return OPc_COP;
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;
    }

    if (o->op_type == OP_SASSIGN)
	return ((o->op_private & OPpASSIGN_BACKWARDS) ? OPc_UNOP : OPc_BINOP);

    if (o->op_type == OP_AELEMFAST) {
#if PERL_VERSION <= 14
	if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
#endif
#ifdef USE_ITHREADS
	    return OPc_PADOP;
#else
	    return OPc_SVOP;
#endif
    }
    
#ifdef USE_ITHREADS
    if (o->op_type == OP_GV || o->op_type == OP_GVSV ||
	o->op_type == OP_RCATLINE)
	return OPc_PADOP;
#endif

    if (o->op_type == OP_CUSTOM)
        custom = 1;

    switch (OP_CLASS(o)) {
    case OA_BASEOP:
	return OPc_BASEOP;

    case OA_UNOP:
	return OPc_UNOP;

    case OA_BINOP:
	return OPc_BINOP;

    case OA_LOGOP:
	return OPc_LOGOP;

    case OA_LISTOP:
	return OPc_LISTOP;

    case OA_PMOP:
	return OPc_PMOP;

    case OA_SVOP:
	return OPc_SVOP;

    case OA_PADOP:
	return OPc_PADOP;

    case OA_PVOP_OR_SVOP:
        /*
         * Character translations (tr///) are usually a PVOP, keeping a 
         * pointer to a table of shorts used to look up translations.
         * Under utf8, however, a simple table isn't practical; instead,
         * the OP is an SVOP (or, under threads, a PADOP),
         * and the SV is a reference to a swash
         * (i.e., an RV pointing to an HV).
         */
	return (!custom &&
		   (o->op_private & (OPpTRANS_TO_UTF|OPpTRANS_FROM_UTF))
	       )
#if  defined(USE_ITHREADS)
		? OPc_PADOP : OPc_PVOP;
#else
		? OPc_SVOP : OPc_PVOP;
#endif

    case OA_LOOP:
	return OPc_LOOP;

    case OA_COP:
	return OPc_COP;

    case OA_BASEOP_OR_UNOP:
	/*
	 * UNI(OP_foo) in toke.c returns token UNI or FUNC1 depending on
	 * whether parens were seen. perly.y uses OPf_SPECIAL to
	 * signal whether a BASEOP had empty parens or none.
	 * Some other UNOPs are created later, though, so the best
	 * test is OPf_KIDS, which is set in newUNOP.
	 */
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    case OA_FILESTATOP:
	/*
	 * The file stat OPs are created via UNI(OP_foo) in toke.c but use
	 * the OPf_REF flag to distinguish between OP types instead of the
	 * usual OPf_SPECIAL flag. As usual, if OPf_KIDS is set, then we
	 * return OPc_UNOP so that walkoptree can find our children. If
	 * OPf_KIDS is not set then we check OPf_REF. Without OPf_REF set
	 * (no argument to the operator) it's an OP; with OPf_REF set it's
	 * an SVOP (and op_sv is the GV for the filehandle argument).
	 */
	return ((o->op_flags & OPf_KIDS) ? OPc_UNOP :
#ifdef USE_ITHREADS
		(o->op_flags & OPf_REF) ? OPc_PADOP : OPc_BASEOP);
#else
		(o->op_flags & OPf_REF) ? OPc_SVOP : OPc_BASEOP);
#endif
    case OA_LOOPEXOP:
	/*
	 * next, last, redo, dump and goto use OPf_SPECIAL to indicate that a
	 * label was omitted (in which case it's a BASEOP) or else a term was
	 * seen. In this last case, all except goto are definitely PVOP but
	 * goto is either a PVOP (with an ordinary constant label), an UNOP
	 * with OPf_STACKED (with a non-constant non-sub) or an UNOP for
	 * OP_REFGEN (with goto &sub) in which case OPf_STACKED also seems to
	 * get set.
	 */
	if (o->op_flags & OPf_STACKED)
	    return OPc_UNOP;
	else if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
	    return OPc_PVOP;
    case OA_METHOP:
	return OPc_METHOP;
    case OA_UNOP_AUX:
	return OPc_UNOP_AUX;
    }
    warn("can't determine class of operator %s, assuming BASEOP\n",
	 OP_NAME(o));
    return OPc_BASEOP;
}

static SV *
make_op_object(pTHX_ const OP *o)
{
    SV *opsv = sv_newmortal();
    sv_setiv(newSVrv(opsv, opclassnames[cc_opclass(aTHX_ o)]), PTR2IV(o));
    return opsv;
}


static SV *
get_overlay_object(pTHX_ const OP *o, const char * const name, U32 namelen)
{
    HE *he;
    SV **svp;
    SV *key;
    SV *sv =get_sv("B::overlay", 0);
    if (!sv || !SvROK(sv))
	return NULL;
    sv = SvRV(sv);
    if (SvTYPE(sv) != SVt_PVHV)
	return NULL;
    key = newSViv(PTR2IV(o));
    he = hv_fetch_ent((HV*)sv, key, 0, 0);
    SvREFCNT_dec(key);
    if (!he)
	return NULL;
    sv = HeVAL(he);
    if (!sv || !SvROK(sv))
	return NULL;
    sv = SvRV(sv);
    if (SvTYPE(sv) != SVt_PVHV)
	return NULL;
    svp = hv_fetch((HV*)sv, name, namelen, 0);
    if (!svp)
	return NULL;
    sv = *svp;
    return sv;
}


static SV *
make_sv_object(pTHX_ SV *sv)
{
    SV *const arg = sv_newmortal();
    const char *type = 0;
    IV iv;
    dMY_CXT;

    for (iv = 0; iv < (IV)(sizeof(specialsv_list)/sizeof(SV*)); iv++) {
	if (sv == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (!type) {
	type = svclassnames[SvTYPE(sv)];
	iv = PTR2IV(sv);
    }
    sv_setiv(newSVrv(arg, type), iv);
    return arg;
}

static SV *
make_temp_object(pTHX_ SV *temp)
{
    SV *target;
    SV *arg = sv_newmortal();
    const char *const type = svclassnames[SvTYPE(temp)];
    const IV iv = PTR2IV(temp);

    target = newSVrv(arg, type);
    sv_setiv(target, iv);

    /* Need to keep our "temp" around as long as the target exists.
       Simplest way seems to be to hang it from magic, and let that clear
       it up.  No vtable, so won't actually get in the way of anything.  */
    sv_magicext(target, temp, PERL_MAGIC_sv, NULL, NULL, 0);
    /* magic object has had its reference count increased, so we must drop
       our reference.  */
    SvREFCNT_dec(temp);
    return arg;
}

static SV *
make_warnings_object(pTHX_ const COP *const cop)
{
    const STRLEN *const warnings = cop->cop_warnings;
    const char *type = 0;
    dMY_CXT;
    IV iv = sizeof(specialsv_list)/sizeof(SV*);

    /* Counting down is deliberate. Before the split between make_sv_object
       and make_warnings_obj there appeared to be a bug - Nullsv and pWARN_STD
       were both 0, so you could never get a B::SPECIAL for pWARN_STD  */

    while (iv--) {
	if ((SV*)warnings == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (type) {
	SV *arg = sv_newmortal();
	sv_setiv(newSVrv(arg, type), iv);
	return arg;
    } else {
	/* B assumes that warnings are a regular SV. Seems easier to keep it
	   happy by making them into a regular SV.  */
	return make_temp_object(aTHX_ newSVpvn((char *)(warnings + 1), *warnings));
    }
}

static SV *
make_cop_io_object(pTHX_ COP *cop)
{
    SV *const value = newSV(0);

    Perl_emulate_cop_io(aTHX_ cop, value);

    if(SvOK(value)) {
	return make_sv_object(aTHX_ value);
    } else {
	SvREFCNT_dec(value);
	return make_sv_object(aTHX_ NULL);
    }
}

static SV *
make_mg_object(pTHX_ MAGIC *mg)
{
    SV *arg = sv_newmortal();
    sv_setiv(newSVrv(arg, "B::MAGIC"), PTR2IV(mg));
    return arg;
}

static SV *
cstring(pTHX_ SV *sv, bool perlstyle)
{
    SV *sstr;

    if (!SvOK(sv))
	return newSVpvs_flags("0", SVs_TEMP);

    sstr = newSVpvs_flags("\"", SVs_TEMP);

    if (perlstyle && SvUTF8(sv)) {
	SV *tmpsv = sv_newmortal(); /* Temporary SV to feed sv_uni_display */
	const STRLEN len = SvCUR(sv);
	const char *s = sv_uni_display(tmpsv, sv, 8*len, UNI_DISPLAY_QQ);
	while (*s)
	{
	    if (*s == '"')
		sv_catpvs(sstr, "\\\"");
	    else if (*s == '$')
		sv_catpvs(sstr, "\\$");
	    else if (*s == '@')
		sv_catpvs(sstr, "\\@");
	    else if (*s == '\\')
	    {
		if (strchr("nrftax\\",*(s+1)))
		    sv_catpvn(sstr, s++, 2);
		else
		    sv_catpvs(sstr, "\\\\");
	    }
	    else /* should always be printable */
		sv_catpvn(sstr, s, 1);
	    ++s;
	}
    }
    else
    {
	/* XXX Optimise? */
	STRLEN len;
	const char *s = SvPV(sv, len);
	for (; len; len--, s++)
	{
	    /* At least try a little for readability */
	    if (*s == '"')
		sv_catpvs(sstr, "\\\"");
	    else if (*s == '\\')
		sv_catpvs(sstr, "\\\\");
            /* trigraphs - bleagh */
            else if (!perlstyle && *s == '?' && len>=3 && s[1] == '?') {
                Perl_sv_catpvf(aTHX_ sstr, "\\%03o", '?');
            }
	    else if (perlstyle && *s == '$')
		sv_catpvs(sstr, "\\$");
	    else if (perlstyle && *s == '@')
		sv_catpvs(sstr, "\\@");
	    else if (isPRINT(*s))
		sv_catpvn(sstr, s, 1);
	    else if (*s == '\n')
		sv_catpvs(sstr, "\\n");
	    else if (*s == '\r')
		sv_catpvs(sstr, "\\r");
	    else if (*s == '\t')
		sv_catpvs(sstr, "\\t");
	    else if (*s == '\a')
		sv_catpvs(sstr, "\\a");
	    else if (*s == '\b')
		sv_catpvs(sstr, "\\b");
	    else if (*s == '\f')
		sv_catpvs(sstr, "\\f");
	    else if (!perlstyle && *s == '\v')
		sv_catpvs(sstr, "\\v");
	    else
	    {
		/* Don't want promotion of a signed -1 char in sprintf args */
		const unsigned char c = (unsigned char) *s;
		Perl_sv_catpvf(aTHX_ sstr, "\\%03o", c);
	    }
	    /* XXX Add line breaks if string is long */
	}
    }
    sv_catpvs(sstr, "\"");
    return sstr;
}

static SV *
cchar(pTHX_ SV *sv)
{
    SV *sstr = newSVpvs_flags("'", SVs_TEMP);
    const char *s = SvPV_nolen(sv);
    /* Don't want promotion of a signed -1 char in sprintf args */
    const unsigned char c = (unsigned char) *s;

    if (c == '\'')
	sv_catpvs(sstr, "\\'");
    else if (c == '\\')
	sv_catpvs(sstr, "\\\\");
    else if (isPRINT(c))
	sv_catpvn(sstr, s, 1);
    else if (c == '\n')
	sv_catpvs(sstr, "\\n");
    else if (c == '\r')
	sv_catpvs(sstr, "\\r");
    else if (c == '\t')
	sv_catpvs(sstr, "\\t");
    else if (c == '\a')
	sv_catpvs(sstr, "\\a");
    else if (c == '\b')
	sv_catpvs(sstr, "\\b");
    else if (c == '\f')
	sv_catpvs(sstr, "\\f");
    else if (c == '\v')
	sv_catpvs(sstr, "\\v");
    else
	Perl_sv_catpvf(aTHX_ sstr, "\\%03o", c);
    sv_catpvs(sstr, "'");
    return sstr;
}

#define PMOP_pmreplstart(o)	o->op_pmstashstartu.op_pmreplstart
#define PMOP_pmreplroot(o)	o->op_pmreplrootu.op_pmreplroot

static SV *
walkoptree(pTHX_ OP *o, const char *method, SV *ref)
{
    dSP;
    OP *kid;
    SV *object;
    const char *const classname = opclassnames[cc_opclass(aTHX_ o)];
    dMY_CXT;

    /* Check that no-one has changed our reference, or is holding a reference
       to it.  */
    if (SvREFCNT(ref) == 1 && SvROK(ref) && SvTYPE(ref) == SVt_RV
	&& (object = SvRV(ref)) && SvREFCNT(object) == 1
	&& SvTYPE(object) == SVt_PVMG && SvIOK_only(object)
	&& !SvMAGICAL(object) && !SvMAGIC(object) && SvSTASH(object)) {
	/* Looks good, so rebless it for the class we need:  */
	sv_bless(ref, gv_stashpv(classname, GV_ADD));
    } else {
	/* Need to make a new one. */
	ref = sv_newmortal();
	object = newSVrv(ref, classname);
    }
    sv_setiv(object, PTR2IV(o));

    if (walkoptree_debug) {
	PUSHMARK(sp);
	XPUSHs(ref);
	PUTBACK;
	perl_call_method("walkoptree_debug", G_DISCARD);
    }
    PUSHMARK(sp);
    XPUSHs(ref);
    PUTBACK;
    perl_call_method(method, G_DISCARD);
    if (o && (o->op_flags & OPf_KIDS)) {
	for (kid = ((UNOP*)o)->op_first; kid; kid = OpSIBLING(kid)) {
	    ref = walkoptree(aTHX_ kid, method, ref);
	}
    }
    if (o && (cc_opclass(aTHX_ o) == OPc_PMOP) && o->op_type != OP_PUSHRE
           && (kid = PMOP_pmreplroot(cPMOPo)))
    {
	ref = walkoptree(aTHX_ kid, method, ref);
    }
    return ref;
}

static SV **
oplist(pTHX_ OP *o, SV **SP)
{
    for(; o; o = o->op_next) {
	if (o->op_opt == 0)
	    break;
	o->op_opt = 0;
	XPUSHs(make_op_object(aTHX_ o));
        switch (o->op_type) {
	case OP_SUBST:
            SP = oplist(aTHX_ PMOP_pmreplstart(cPMOPo), SP);
            continue;
	case OP_SORT:
	    if (o->op_flags & OPf_STACKED && o->op_flags & OPf_SPECIAL) {
		OP *kid = OpSIBLING(cLISTOPo->op_first);   /* pass pushmark */
		kid = kUNOP->op_first;                      /* pass rv2gv */
		kid = kUNOP->op_first;                      /* pass leave */
		SP = oplist(aTHX_ kid->op_next, SP);
	    }
	    continue;
        }
	switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
	case OA_LOGOP:
	    SP = oplist(aTHX_ cLOGOPo->op_other, SP);
	    break;
	case OA_LOOP:
	    SP = oplist(aTHX_ cLOOPo->op_lastop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_nextop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_redoop, SP);
	    break;
	}
    }
    return SP;
}

typedef OP	*B__OP;
typedef UNOP	*B__UNOP;
typedef BINOP	*B__BINOP;
typedef LOGOP	*B__LOGOP;
typedef LISTOP	*B__LISTOP;
typedef PMOP	*B__PMOP;
typedef SVOP	*B__SVOP;
typedef PADOP	*B__PADOP;
typedef PVOP	*B__PVOP;
typedef LOOP	*B__LOOP;
typedef COP	*B__COP;
typedef METHOP  *B__METHOP;

typedef SV	*B__SV;
typedef SV	*B__IV;
typedef SV	*B__PV;
typedef SV	*B__NV;
typedef SV	*B__PVMG;
#if PERL_VERSION >= 11
typedef SV	*B__REGEXP;
#endif
typedef SV	*B__PVLV;
typedef SV	*B__BM;
typedef SV	*B__RV;
typedef SV	*B__FM;
typedef AV	*B__AV;
typedef HV	*B__HV;
typedef CV	*B__CV;
typedef GV	*B__GV;
typedef IO	*B__IO;

typedef MAGIC	*B__MAGIC;
typedef HE      *B__HE;
typedef struct refcounted_he	*B__RHE;
#ifdef PadlistARRAY
typedef PADLIST	*B__PADLIST;
#endif
typedef PADNAMELIST *B__PADNAMELIST;
typedef PADNAME	*B__PADNAME;


#ifdef MULTIPLICITY
#  define ASSIGN_COMMON_ALIAS(prefix, var) \
    STMT_START { XSANY.any_i32 = STRUCT_OFFSET(struct interpreter, prefix##var); } STMT_END
#else
#  define ASSIGN_COMMON_ALIAS(prefix, var) \
    STMT_START { XSANY.any_ptr = (void *)&PL_##var; } STMT_END
#endif

/* This needs to be ALIASed in a custom way, hence can't easily be defined as
   a regular XSUB.  */
static XSPROTO(intrpvar_sv_common); /* prototype to pass -Wmissing-prototypes */
static XSPROTO(intrpvar_sv_common)
{
    dVAR;
    dXSARGS;
    SV *ret;
    if (items != 0)
       croak_xs_usage(cv,  "");
#ifdef MULTIPLICITY
    ret = *(SV **)(XSANY.any_i32 + (char *)my_perl);
#else
    ret = *(SV **)(XSANY.any_ptr);
#endif
    ST(0) = make_sv_object(aTHX_ ret);
    XSRETURN(1);
}



#define SVp                 0x0
#define U32p                0x1
#define line_tp             0x2
#define OPp                 0x3
#define PADOFFSETp          0x4
#define U8p                 0x5
#define IVp                 0x6
#define char_pp             0x7
/* Keep this last:  */
#define op_offset_special   0x8

/* table that drives most of the B::*OP methods */

const struct OP_methods {
    const char *name;
    U8 namelen;
    U8    type; /* if op_offset_special, access is handled on a case-by-case basis */
    U16 offset;
} op_methods[] = {
  { STR_WITH_LEN("next"),    OPp,    STRUCT_OFFSET(struct op, op_next),     },/* 0*/
  { STR_WITH_LEN("sibling"), op_offset_special, 0,                          },/* 1*/
  { STR_WITH_LEN("targ"),    PADOFFSETp, STRUCT_OFFSET(struct op, op_targ), },/* 2*/
  { STR_WITH_LEN("flags"),   U8p,    STRUCT_OFFSET(struct op, op_flags),    },/* 3*/
  { STR_WITH_LEN("private"), U8p,    STRUCT_OFFSET(struct op, op_private),  },/* 4*/
  { STR_WITH_LEN("first"),   OPp,    STRUCT_OFFSET(struct unop, op_first),  },/* 5*/
  { STR_WITH_LEN("last"),    OPp,    STRUCT_OFFSET(struct binop, op_last),  },/* 6*/
  { STR_WITH_LEN("other"),   OPp,    STRUCT_OFFSET(struct logop, op_other), },/* 7*/
  { STR_WITH_LEN("pmreplstart"), op_offset_special, 0,                 },/* 8*/
  { STR_WITH_LEN("redoop"),  OPp,    STRUCT_OFFSET(struct loop, op_redoop), },/* 9*/
  { STR_WITH_LEN("nextop"),  OPp,    STRUCT_OFFSET(struct loop, op_nextop), },/*10*/
  { STR_WITH_LEN("lastop"),  OPp,    STRUCT_OFFSET(struct loop, op_lastop), },/*11*/
  { STR_WITH_LEN("pmflags"), U32p,   STRUCT_OFFSET(struct pmop, op_pmflags),},/*12*/
#if PERL_VERSION >= 17
  { STR_WITH_LEN("code_list"),OPp,   STRUCT_OFFSET(struct pmop, op_code_list),},/*13*/
#else
  { STR_WITH_LEN("code_list"),op_offset_special, 0,                         }, /*13*/
#endif
  { STR_WITH_LEN("sv"),      SVp,     STRUCT_OFFSET(struct svop, op_sv),    },/*14*/
  { STR_WITH_LEN("gv"),      SVp,     STRUCT_OFFSET(struct svop, op_sv),    },/*15*/
  { STR_WITH_LEN("padix"),   PADOFFSETp,STRUCT_OFFSET(struct padop, op_padix),},/*16*/
  { STR_WITH_LEN("cop_seq"), U32p,    STRUCT_OFFSET(struct cop, cop_seq),   },/*17*/
  { STR_WITH_LEN("line"),    line_tp, STRUCT_OFFSET(struct cop, cop_line),  },/*18*/
  { STR_WITH_LEN("hints"),   U32p,    STRUCT_OFFSET(struct cop, cop_hints), },/*19*/
#ifdef USE_ITHREADS
  { STR_WITH_LEN("pmoffset"),IVp,     STRUCT_OFFSET(struct pmop, op_pmoffset),},/*20*/
  { STR_WITH_LEN("filegv"),  op_offset_special, 0,                     },/*21*/
  { STR_WITH_LEN("file"),    char_pp, STRUCT_OFFSET(struct cop, cop_file),  },/*22*/
  { STR_WITH_LEN("stash"),   op_offset_special, 0,                     },/*23*/
#  if PERL_VERSION < 17
  { STR_WITH_LEN("stashpv"), char_pp, STRUCT_OFFSET(struct cop, cop_stashpv),}, /*24*/
  { STR_WITH_LEN("stashoff"),op_offset_special, 0,                     },/*25*/
#  else
  { STR_WITH_LEN("stashpv"), op_offset_special, 0,                     },/*24*/
  { STR_WITH_LEN("stashoff"),PADOFFSETp,STRUCT_OFFSET(struct cop,cop_stashoff),},/*25*/
#  endif
#else
  { STR_WITH_LEN("pmoffset"),op_offset_special, 0,                     },/*20*/
  { STR_WITH_LEN("filegv"),  SVp,     STRUCT_OFFSET(struct cop, cop_filegv),},/*21*/
  { STR_WITH_LEN("file"),    op_offset_special, 0,                     },/*22*/
  { STR_WITH_LEN("stash"),   SVp,     STRUCT_OFFSET(struct cop, cop_stash), },/*23*/
  { STR_WITH_LEN("stashpv"), op_offset_special, 0,                     },/*24*/
  { STR_WITH_LEN("stashoff"),op_offset_special, 0,                     },/*25*/
#endif
  { STR_WITH_LEN("size"),    op_offset_special, 0,                     },/*26*/
  { STR_WITH_LEN("name"),    op_offset_special, 0,                     },/*27*/
  { STR_WITH_LEN("desc"),    op_offset_special, 0,                     },/*28*/
  { STR_WITH_LEN("ppaddr"),  op_offset_special, 0,                     },/*29*/
  { STR_WITH_LEN("type"),    op_offset_special, 0,                     },/*30*/
  { STR_WITH_LEN("opt"),     op_offset_special, 0,                     },/*31*/
  { STR_WITH_LEN("spare"),   op_offset_special, 0,                     },/*32*/
  { STR_WITH_LEN("children"),op_offset_special, 0,                     },/*33*/
  { STR_WITH_LEN("pmreplroot"), op_offset_special, 0,                  },/*34*/
  { STR_WITH_LEN("pmstashpv"), op_offset_special, 0,                   },/*35*/
  { STR_WITH_LEN("pmstash"), op_offset_special, 0,                     },/*36*/
  { STR_WITH_LEN("precomp"), op_offset_special, 0,                     },/*37*/
  { STR_WITH_LEN("reflags"), op_offset_special, 0,                     },/*38*/
  { STR_WITH_LEN("sv"),      op_offset_special, 0,                     },/*39*/
  { STR_WITH_LEN("gv"),      op_offset_special, 0,                     },/*40*/
  { STR_WITH_LEN("pv"),      op_offset_special, 0,                     },/*41*/
  { STR_WITH_LEN("label"),   op_offset_special, 0,                     },/*42*/
  { STR_WITH_LEN("arybase"), op_offset_special, 0,                     },/*43*/
  { STR_WITH_LEN("warnings"),op_offset_special, 0,                     },/*44*/
  { STR_WITH_LEN("io"),      op_offset_special, 0,                     },/*45*/
  { STR_WITH_LEN("hints_hash"),op_offset_special, 0,                   },/*46*/
#if PERL_VERSION >= 17
  { STR_WITH_LEN("slabbed"), op_offset_special, 0,                     },/*47*/
  { STR_WITH_LEN("savefree"),op_offset_special, 0,                     },/*48*/
  { STR_WITH_LEN("static"),  op_offset_special, 0,                     },/*49*/
#  if PERL_VERSION >= 19
  { STR_WITH_LEN("folded"),  op_offset_special, 0,                     },/*50*/
  { STR_WITH_LEN("moresib"), op_offset_special, 0,                     },/*51*/
  { STR_WITH_LEN("parent"),  op_offset_special, 0,                     },/*52*/
#  endif
#endif
#if PERL_VERSION >= 21
  { STR_WITH_LEN("first"),   op_offset_special, 0,                     },/*53*/
  { STR_WITH_LEN("meth_sv"), op_offset_special, 0,                     },/*54*/
  { STR_WITH_LEN("pmregexp"),op_offset_special, 0,                     },/*55*/
#  ifdef USE_ITHREADS
  { STR_WITH_LEN("rclass"),  op_offset_special, 0,                     },/*56*/
#  else
  { STR_WITH_LEN("rclass"),  op_offset_special, 0,                     },/*56*/
#  endif
#endif
};

#include "const-c.inc"

#line 791 "B.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 935 "B.c"

/* INCLUDE:  Including 'const-xs.inc' from 'B.xs' */


/* INCLUDE: Returning to 'B.xs' from 'const-xs.inc' */

#ifndef PL_formfeed
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_B_formfeed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_formfeed)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 837 "B.xs"
	PUSHs(make_sv_object(aTHX_ GvSV(gv_fetchpvs("\f", GV_ADD, SVt_PV))));
#line 957 "B.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_B_amagic_generation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_amagic_generation)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	long	RETVAL;
	dXSTARG;
#line 844 "B.xs"
	RETVAL = PL_amagic_generation;
#line 976 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_comppadlist); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_comppadlist)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 851 "B.xs"
	PADLIST *padlist = CvPADLIST(PL_main_cv ? PL_main_cv : PL_compcv);
#line 994 "B.c"
#line 853 "B.xs"
#ifdef PadlistARRAY
	{
	    SV * const rv = sv_newmortal();
	    sv_setiv(newSVrv(rv, padlist ? "B::PADLIST" : "B::NULL"),
		     PTR2IV(padlist));
	    PUSHs(rv);
	}
#else
	PUSHs(make_sv_object(aTHX_ (SV *)padlist));
#endif
#line 1006 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_sv_undef); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_sv_undef)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 870 "B.xs"
	PUSHs(make_sv_object(aTHX_ ix > 1 ? &PL_sv_yes
					  : ix < 1 ? &PL_sv_undef
						   : &PL_sv_no));
#line 1027 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_main_root); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_main_root)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 879 "B.xs"
	PUSHs(make_op_object(aTHX_ ix ? PL_main_start : PL_main_root));
#line 1046 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_sub_generation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_sub_generation)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	UV	RETVAL;
	dXSTARG;
#line 886 "B.xs"
	RETVAL = ix ? PL_dowarn : PL_sub_generation;
#line 1065 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_walkoptree); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_walkoptree)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "op, method");
    {
	B__OP	op;
	const char *	method = (const char *)SvPV_nolen(ST(1))
;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    op = INT2PTR(B__OP,tmp);
	}
	else
	    croak("op is not a reference")
;
#line 895 "B.xs"
	(void) walkoptree(aTHX_ op, method, &PL_sv_undef);
#line 1092 "B.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_B_walkoptree_debug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_walkoptree_debug)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 900 "B.xs"
	dMY_CXT;
	RETVAL = walkoptree_debug;
	if (items > 0 && SvTRUE(ST(1)))
	    walkoptree_debug = 1;
#line 1111 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define address(sv) PTR2IV(sv)

XS_EUPXS(XS_B_address); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_address)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;
	IV	RETVAL;
	dXSTARG;

	RETVAL = address(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_svref_2object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_svref_2object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sv = ST(0)
;
#line 917 "B.xs"
	if (!SvROK(sv))
	    croak("argument is not a reference");
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));
#line 1153 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_opnumber); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_opnumber)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	const char *	name = (const char *)SvPV_nolen(ST(0))
;
#line 925 "B.xs"
{
 int i; 
 IV  result = -1;
 ST(0) = sv_newmortal();
 if (strncmp(name,"pp_",3) == 0)
   name += 3;
 for (i = 0; i < PL_maxo; i++)
  {
   if (strcmp(name, PL_op_name[i]) == 0)
    {
     result = i;
     break;
    }
  }
 sv_setiv(ST(0),result);
}
#line 1186 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_ppname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_ppname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "opnum");
    {
	int	opnum = (int)SvIV(ST(0))
;
#line 946 "B.xs"
	ST(0) = sv_newmortal();
	if (opnum >= 0 && opnum < PL_maxo)
	    Perl_sv_setpvf(aTHX_ ST(0), "pp_%s", PL_op_name[opnum]);
#line 1205 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;
#line 954 "B.xs"
	STRLEN len;
	U32 hash = 0;
	const char *s = SvPVbyte(sv, len);
	PERL_HASH(hash, s, len);
	ST(0) = sv_2mortal(Perl_newSVpvf(aTHX_ "0x%"UVxf, (UV)hash));
#line 1226 "B.c"
    }
    XSRETURN(1);
}

#define cast_I32(foo) (I32)foo

XS_EUPXS(XS_B_cast_I32); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_cast_I32)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	IV	i = (IV)SvIV(ST(0))
;
	IV	RETVAL;
	dXSTARG;

	RETVAL = cast_I32(i);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_minus_c); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_minus_c)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 970 "B.xs"
	if (ix)
	    PL_savebegin = TRUE;
	else
	    PL_minus_c = TRUE;
#line 1265 "B.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_B_cstring); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_cstring)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sv = ST(0)
;
#line 982 "B.xs"
	PUSHs(ix == 2 ? cchar(aTHX_ sv) : cstring(aTHX_ sv, (bool)ix));
#line 1285 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_threadsv_names); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_threadsv_names)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 986 "B.xs"
#line 1302 "B.c"
	PUTBACK;
	return;
    }
}

#ifdef USE_ITHREADS
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_B_CLONE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_CLONE)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 993 "B.xs"
    PUTBACK; /* some vars go out of scope now in machine code */
    {
	MY_CXT_CLONE;
	B_init_my_cxt(aTHX_ &(MY_CXT));
    }
    return; /* dont execute another implied XSPP PUTBACK */
#line 1327 "B.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_B__OP_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__OP_next)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__OP	o;
#line 1070 "B.xs"
	SV *ret;
#line 1348 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1072 "B.xs"
	if (ix < 0 || (U32)ix >= C_ARRAY_LENGTH(op_methods))
	    croak("Illegal alias %d for B::*OP::next", (int)ix);
	ret = get_overlay_object(aTHX_ o,
			    op_methods[ix].name, op_methods[ix].namelen);
	if (ret) {
	    ST(0) = ret;
	    XSRETURN(1);
	}

	/* handle non-direct field access */

	if (op_methods[ix].type == op_offset_special)
	    switch (ix) {
	    case 1: /* B::OP::op_sibling */
		ret = make_op_object(aTHX_ OpSIBLING(o));
		break;

	    case 8: /* B::PMOP::pmreplstart */
		ret = make_op_object(aTHX_
				cPMOPo->op_type == OP_SUBST
				    ?  cPMOPo->op_pmstashstartu.op_pmreplstart
				    : NULL
		      );
		break;
#ifdef USE_ITHREADS
	    case 21: /* B::COP::filegv */
		ret = make_sv_object(aTHX_ (SV *)CopFILEGV((COP*)o));
		break;
#endif
#ifndef USE_ITHREADS
	    case 22: /* B::COP::file */
		ret = sv_2mortal(newSVpv(CopFILE((COP*)o), 0));
		break;
#endif
#ifdef USE_ITHREADS
	    case 23: /* B::COP::stash */
		ret = make_sv_object(aTHX_ (SV *)CopSTASH((COP*)o));
		break;
#endif
#if PERL_VERSION >= 17 || !defined USE_ITHREADS
	    case 24: /* B::COP::stashpv */
#  if PERL_VERSION >= 17
		ret = sv_2mortal(CopSTASH((COP*)o)
				&& SvTYPE(CopSTASH((COP*)o)) == SVt_PVHV
		    ? newSVhek(HvNAME_HEK(CopSTASH((COP*)o)))
		    : &PL_sv_undef);
#  else
		ret = sv_2mortal(newSVpv(CopSTASHPV((COP*)o), 0));
#  endif
		break;
#endif
	    case 26: /* B::OP::size */
		ret = sv_2mortal(newSVuv((UV)(opsizes[cc_opclass(aTHX_ o)])));
		break;
	    case 27: /* B::OP::name */
	    case 28: /* B::OP::desc */
		ret = sv_2mortal(newSVpv(
			    (char *)(ix == 28 ? OP_DESC(o) : OP_NAME(o)), 0));
		break;
	    case 29: /* B::OP::ppaddr */
		{
		    int i;
		    ret = sv_2mortal(Perl_newSVpvf(aTHX_ "PL_ppaddr[OP_%s]",
						  PL_op_name[o->op_type]));
		    for (i=13; (STRLEN)i < SvCUR(ret); ++i)
			SvPVX(ret)[i] = toUPPER(SvPVX(ret)[i]);
		}
		break;
	    case 30: /* B::OP::type  */
	    case 31: /* B::OP::opt   */
	    case 32: /* B::OP::spare */
#if PERL_VERSION >= 17
	    case 47: /* B::OP::slabbed  */
	    case 48: /* B::OP::savefree */
	    case 49: /* B::OP::static   */
#if PERL_VERSION >= 19
	    case 50: /* B::OP::folded   */
	    case 51: /* B::OP::moresib  */
#endif
#endif
	    /* These are all bitfields, so we can't take their addresses */
		ret = sv_2mortal(newSVuv((UV)(
				      ix == 30 ? o->op_type
		                    : ix == 31 ? o->op_opt
		                    : ix == 47 ? o->op_slabbed
		                    : ix == 48 ? o->op_savefree
		                    : ix == 49 ? o->op_static
		                    : ix == 50 ? o->op_folded
		                    : ix == 51 ? o->op_moresib
		                    :            o->op_spare)));
		break;
	    case 33: /* B::LISTOP::children */
		{
		    OP *kid;
		    UV i = 0;
		    for (kid = ((LISTOP*)o)->op_first; kid; kid = OpSIBLING(kid))
			i++;
		    ret = sv_2mortal(newSVuv(i));
		}
		break;
	    case 34: /* B::PMOP::pmreplroot */
		if (cPMOPo->op_type == OP_PUSHRE) {
#ifdef USE_ITHREADS
		    ret = sv_newmortal();
		    sv_setiv(ret, cPMOPo->op_pmreplrootu.op_pmtargetoff);
#else
		    GV *const target = cPMOPo->op_pmreplrootu.op_pmtargetgv;
		    ret = sv_newmortal();
		    sv_setiv(newSVrv(ret, target ?
				     svclassnames[SvTYPE((SV*)target)] : "B::SV"),
			     PTR2IV(target));
#endif
		}
		else {
		    OP *const root = cPMOPo->op_pmreplrootu.op_pmreplroot;
		    ret = make_op_object(aTHX_ root);
		}
		break;
#ifdef USE_ITHREADS
	    case 35: /* B::PMOP::pmstashpv */
		ret = sv_2mortal(newSVpv(PmopSTASHPV(cPMOPo),0));
		break;
#else
	    case 36: /* B::PMOP::pmstash */
		ret = make_sv_object(aTHX_ (SV *) PmopSTASH(cPMOPo));
		break;
#endif
	    case 37: /* B::PMOP::precomp */
	    case 38: /* B::PMOP::reflags */
		{
		    REGEXP *rx = PM_GETRE(cPMOPo);
		    ret = sv_newmortal();
		    if (rx) {
			if (ix==38) {
			    sv_setuv(ret, RX_EXTFLAGS(rx));
			}
			else {
			    sv_setpvn(ret, RX_PRECOMP(rx), RX_PRELEN(rx));
                            if (RX_UTF8(rx))
                                SvUTF8_on(ret);
			}
		    }
		}
		break;
	    case 39: /* B::PADOP::sv */
	    case 40: /* B::PADOP::gv */
		/* PADOPs should only be created on threaded builds.
                 * They don't have an sv or gv field, just an op_padix
                 * field. Leave it to the caller to retrieve padix
                 * and look up th value in the pad. Don't do it here,
                 * becuase PL_curpad is the pad of the caller, not the
                 * pad of the sub the op is part of */
		ret = make_sv_object(aTHX_ NULL);
		break;
	    case 41: /* B::PVOP::pv */
		/* OP_TRANS uses op_pv to point to a table of 256 or >=258
		 * shorts whereas other PVOPs point to a null terminated
		 * string.  */
		if (    (cPVOPo->op_type == OP_TRANS
			|| cPVOPo->op_type == OP_TRANSR) &&
			(cPVOPo->op_private & OPpTRANS_COMPLEMENT) &&
			!(cPVOPo->op_private & OPpTRANS_DELETE))
		{
		    const short* const tbl = (short*)cPVOPo->op_pv;
		    const short entries = 257 + tbl[256];
		    ret = newSVpvn_flags(cPVOPo->op_pv, entries * sizeof(short), SVs_TEMP);
		}
		else if (cPVOPo->op_type == OP_TRANS || cPVOPo->op_type == OP_TRANSR) {
		    ret = newSVpvn_flags(cPVOPo->op_pv, 256 * sizeof(short), SVs_TEMP);
		}
		else
		    ret = newSVpvn_flags(cPVOPo->op_pv, strlen(cPVOPo->op_pv), SVs_TEMP);
		break;
	    case 42: /* B::COP::label */
		ret = sv_2mortal(newSVpv(CopLABEL(cCOPo),0));
		break;
	    case 43: /* B::COP::arybase */
		ret = sv_2mortal(newSVuv(0));
		break;
	    case 44: /* B::COP::warnings */
		ret = make_warnings_object(aTHX_ cCOPo);
		break;
	    case 45: /* B::COP::io */
		ret = make_cop_io_object(aTHX_ cCOPo);
		break;
	    case 46: /* B::COP::hints_hash */
		ret = sv_newmortal();
		sv_setiv(newSVrv(ret, "B::RHE"),
			PTR2IV(CopHINTHASH_get(cCOPo)));
		break;
	    case 52: /* B::OP::parent */
#ifdef PERL_OP_PARENT
		ret = make_op_object(aTHX_ op_parent(o));
#else
		ret = make_op_object(aTHX_ NULL);
#endif
		break;
	    case 53: /* B::METHOP::first   */
                /* METHOP struct has an op_first/op_meth_sv union
                 * as its first extra field. How to interpret the
                 * union depends on the op type. For the purposes of
                 * B, we treat it as a struct with both fields present,
                 * where one of the fields always happens to be null
                 * (i.e. we return NULL in preference to croaking with
                 * 'method not implemented').
                 */
		ret = make_op_object(aTHX_
                            o->op_type == OP_METHOD
                                ? cMETHOPx(o)->op_u.op_first : NULL);
		break;
	    case 54: /* B::METHOP::meth_sv */
                /* see comment above about METHOP */
		ret = make_sv_object(aTHX_
                            o->op_type == OP_METHOD
                                ? NULL : cMETHOPx(o)->op_u.op_meth_sv);
		break;
	    case 55: /* B::PMOP::pmregexp */
		ret = make_sv_object(aTHX_ (SV *)PM_GETRE(cPMOPo));
		break;
	    case 56: /* B::METHOP::rclass */
#ifdef USE_ITHREADS
		ret = sv_2mortal(newSVuv(
		    (o->op_type == OP_METHOD_REDIR ||
		     o->op_type == OP_METHOD_REDIR_SUPER) ?
		      cMETHOPx(o)->op_rclass_targ : 0
		));
#else
		ret = make_sv_object(aTHX_
		    (o->op_type == OP_METHOD_REDIR ||
		     o->op_type == OP_METHOD_REDIR_SUPER) ?
		      cMETHOPx(o)->op_rclass_sv : NULL
		);
#endif
		break;
	    default:
		croak("method %s not implemented", op_methods[ix].name);
	} else {
	    /* do a direct structure offset lookup */
	    const char *const ptr = (char *)o + op_methods[ix].offset;
	    switch (op_methods[ix].type) {
	    case OPp:
		ret = make_op_object(aTHX_ *((OP **)ptr));
		break;
	    case PADOFFSETp:
		ret = sv_2mortal(newSVuv(*((PADOFFSET*)ptr)));
		break;
	    case U8p:
		ret = sv_2mortal(newSVuv(*((U8*)ptr)));
		break;
	    case U32p:
		ret = sv_2mortal(newSVuv(*((U32*)ptr)));
		break;
	    case SVp:
		ret = make_sv_object(aTHX_ *((SV **)ptr));
		break;
	    case line_tp:
		ret = sv_2mortal(newSVuv(*((line_t *)ptr)));
		break;
	    case IVp:
		ret = sv_2mortal(newSViv(*((IV*)ptr)));
		break;
	    case char_pp:
		ret = sv_2mortal(newSVpv(*((char **)ptr), 0));
		break;
	    default:
		croak("Illegal type 0x%x for B::*OP::%s",
		      (unsigned)op_methods[ix].type, op_methods[ix].name);
	    }
	}
	ST(0) = ret;
	XSRETURN(1);
#line 1629 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__OP_oplist); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__OP_oplist)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__OP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1349 "B.xs"
	SP = oplist(aTHX_ o, SP);
#line 1656 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__UNOP_AUX_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__UNOP_AUX_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "o, cv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__OP	o;
	B__CV	cv;
#line 1369 "B.xs"
	SV *ret;
#line 1676 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;

	if (SvROK(ST(1))) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 1371 "B.xs"
        switch (o->op_type) {
        case OP_MULTIDEREF:
            ret = multideref_stringify(o, cv);
            break;
        default:
            ret = sv_2mortal(newSVpvn("", 0));
        }
	ST(0) = ret;
	XSRETURN(1);
#line 1703 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__UNOP_AUX_aux_list); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__UNOP_AUX_aux_list)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "o, cv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__OP	o;
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;

	if (SvROK(ST(1))) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 1392 "B.xs"
        PERL_UNUSED_VAR(cv); /* not needed on unthreaded builds */
        switch (o->op_type) {
        default:
            XSRETURN(0); /* by default, an empty list */

        case OP_MULTIDEREF:
#ifdef USE_ITHREADS
#  define ITEM_SV(item) *av_fetch(comppad, (item)->pad_offset, FALSE);
#else
#  define ITEM_SV(item) UNOP_AUX_item_sv(item)
#endif
            {
                UNOP_AUX_item *items = cUNOP_AUXo->op_aux;
                UV actions = items->uv;
                UV len = items[-1].uv;
                SV *sv;
                bool last = 0;
                bool is_hash = FALSE;
#ifdef USE_ITHREADS
                PADLIST * const padlist = CvPADLIST(cv);
                PAD *comppad = PadlistARRAY(padlist)[1];
#endif

                EXTEND(SP, len);
                PUSHs(sv_2mortal(newSViv(actions)));

                while (!last) {
                    switch (actions & MDEREF_ACTION_MASK) {

                    case MDEREF_reload:
                        actions = (++items)->uv;
                        PUSHs(sv_2mortal(newSVuv(actions)));
                        continue;
                        NOT_REACHED; /* NOTREACHED */

                    case MDEREF_HV_padhv_helem:
                        is_hash = TRUE;
                        /* FALLTHROUGH */
                    case MDEREF_AV_padav_aelem:
                        PUSHs(sv_2mortal(newSVuv((++items)->pad_offset)));
                        goto do_elem;
                        NOT_REACHED; /* NOTREACHED */

                    case MDEREF_HV_gvhv_helem:
                        is_hash = TRUE;
                        /* FALLTHROUGH */
                    case MDEREF_AV_gvav_aelem:
                        sv = ITEM_SV(++items);
                        PUSHs(make_sv_object(aTHX_ sv));
                        goto do_elem;
                        NOT_REACHED; /* NOTREACHED */

                    case MDEREF_HV_gvsv_vivify_rv2hv_helem:
                        is_hash = TRUE;
                        /* FALLTHROUGH */
                    case MDEREF_AV_gvsv_vivify_rv2av_aelem:
                        sv = ITEM_SV(++items);
                        PUSHs(make_sv_object(aTHX_ sv));
                        goto do_vivify_rv2xv_elem;
                        NOT_REACHED; /* NOTREACHED */

                    case MDEREF_HV_padsv_vivify_rv2hv_helem:
                        is_hash = TRUE;
                        /* FALLTHROUGH */
                    case MDEREF_AV_padsv_vivify_rv2av_aelem:
                        PUSHs(sv_2mortal(newSVuv((++items)->pad_offset)));
                        goto do_vivify_rv2xv_elem;
                        NOT_REACHED; /* NOTREACHED */

                    case MDEREF_HV_pop_rv2hv_helem:
                    case MDEREF_HV_vivify_rv2hv_helem:
                        is_hash = TRUE;
                        /* FALLTHROUGH */
                    do_vivify_rv2xv_elem:
                    case MDEREF_AV_pop_rv2av_aelem:
                    case MDEREF_AV_vivify_rv2av_aelem:
                    do_elem:
                        switch (actions & MDEREF_INDEX_MASK) {
                        case MDEREF_INDEX_none:
                            last = 1;
                            break;
                        case MDEREF_INDEX_const:
                            if (is_hash) {
                                sv = ITEM_SV(++items);
                                PUSHs(make_sv_object(aTHX_ sv));
                            }
                            else
                                PUSHs(sv_2mortal(newSViv((++items)->iv)));
                            break;
                        case MDEREF_INDEX_padsv:
                            PUSHs(sv_2mortal(newSVuv((++items)->pad_offset)));
                            break;
                        case MDEREF_INDEX_gvsv:
                            sv = ITEM_SV(++items);
                            PUSHs(make_sv_object(aTHX_ sv));
                            break;
                        }
                        if (actions & MDEREF_FLAG_last)
                            last = 1;
                        is_hash = FALSE;

                        break;
                    } /* switch */

                    actions >>= MDEREF_SHIFT;
                } /* while */
                XSRETURN(len);

            } /* OP_MULTIDEREF */
        } /* switch */
#line 1848 "B.c"
	PUTBACK;
	return;
    }
}

#define MAGICAL_FLAG_BITS (SVs_GMG|SVs_SMG|SVs_RMG)

XS_EUPXS(XS_B__SV_REFCNT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__SV_REFCNT)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1519 "B.xs"
	RETVAL = ix ? (SvFLAGS(sv) & (U32)ix) : SvREFCNT(sv);
#line 1877 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__SV_object_2svref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__SV_object_2svref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__SV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1527 "B.xs"
	ST(0) = sv_2mortal(newRV(sv));
	XSRETURN(1);
#line 1905 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__IV_IV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IV_IV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference")
;

	RETVAL = SvIV(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define sv_SVp		0x00000
#define sv_IVp		0x10000
#define sv_UVp		0x20000
#define sv_STRLENp	0x30000
#define sv_U32p		0x40000
#define sv_U8p		0x50000
#define sv_char_pp	0x60000
#define sv_NVp		0x70000
#define sv_char_p	0x80000
#define sv_SSize_tp	0x90000
#define sv_I32p		0xA0000
#define sv_U16p		0xB0000
#define IV_ivx_ix	sv_IVp | STRUCT_OFFSET(struct xpviv, xiv_iv)
#define IV_uvx_ix	sv_UVp | STRUCT_OFFSET(struct xpvuv, xuv_uv)
#define NV_nvx_ix	sv_NVp | STRUCT_OFFSET(struct xpvnv, xnv_u.xnv_nv)
#define PV_cur_ix	sv_STRLENp | STRUCT_OFFSET(struct xpv, xpv_cur)
#define PV_len_ix	sv_STRLENp | STRUCT_OFFSET(struct xpv, xpv_len)
#define PVMG_stash_ix	sv_SVp | STRUCT_OFFSET(struct xpvmg, xmg_stash)
#if PERL_VERSION > 18
#    define PVBM_useful_ix	sv_IVp | STRUCT_OFFSET(struct xpviv, xiv_u.xivu_iv)
#elif PERL_VERSION > 14
#    define PVBM_useful_ix	sv_I32p | STRUCT_OFFSET(struct xpvgv, xnv_u.xbm_s.xbm_useful)
#else
#define PVBM_useful_ix	sv_I32p | STRUCT_OFFSET(struct xpvgv, xiv_u.xivu_i32)
#endif
#define PVLV_targoff_ix	sv_U32p | STRUCT_OFFSET(struct xpvlv, xlv_targoff)
#define PVLV_targlen_ix	sv_U32p | STRUCT_OFFSET(struct xpvlv, xlv_targlen)
#define PVLV_targ_ix	sv_SVp | STRUCT_OFFSET(struct xpvlv, xlv_targ)
#define PVLV_type_ix	sv_char_p | STRUCT_OFFSET(struct xpvlv, xlv_type)
#define PVGV_stash_ix	sv_SVp | STRUCT_OFFSET(struct xpvgv, xnv_u.xgv_stash)
#define PVGV_flags_ix	sv_STRLENp | STRUCT_OFFSET(struct xpvgv, xpv_cur)
#define PVIO_lines_ix	sv_IVp | STRUCT_OFFSET(struct xpvio, xiv_iv)
#define PVIO_page_ix	    sv_IVp | STRUCT_OFFSET(struct xpvio, xio_page)
#define PVIO_page_len_ix    sv_IVp | STRUCT_OFFSET(struct xpvio, xio_page_len)
#define PVIO_lines_left_ix  sv_IVp | STRUCT_OFFSET(struct xpvio, xio_lines_left)
#define PVIO_top_name_ix    sv_char_pp | STRUCT_OFFSET(struct xpvio, xio_top_name)
#define PVIO_top_gv_ix	    sv_SVp | STRUCT_OFFSET(struct xpvio, xio_top_gv)
#define PVIO_fmt_name_ix    sv_char_pp | STRUCT_OFFSET(struct xpvio, xio_fmt_name)
#define PVIO_fmt_gv_ix	    sv_SVp | STRUCT_OFFSET(struct xpvio, xio_fmt_gv)
#define PVIO_bottom_name_ix sv_char_pp | STRUCT_OFFSET(struct xpvio, xio_bottom_name)
#define PVIO_bottom_gv_ix   sv_SVp | STRUCT_OFFSET(struct xpvio, xio_bottom_gv)
#define PVIO_type_ix	    sv_char_p | STRUCT_OFFSET(struct xpvio, xio_type)
#define PVIO_flags_ix	    sv_U8p | STRUCT_OFFSET(struct xpvio, xio_flags)
#define PVAV_max_ix	sv_SSize_tp | STRUCT_OFFSET(struct xpvav, xav_max)
#define PVCV_stash_ix	sv_SVp | STRUCT_OFFSET(struct xpvcv, xcv_stash) 
#if PERL_VERSION > 17 || (PERL_VERSION == 17 && PERL_SUBVERSION >= 3)
# define PVCV_gv_ix	sv_SVp | STRUCT_OFFSET(struct xpvcv, xcv_gv_u.xcv_gv)
#else
# define PVCV_gv_ix	sv_SVp | STRUCT_OFFSET(struct xpvcv, xcv_gv)
#endif
#define PVCV_file_ix	sv_char_pp | STRUCT_OFFSET(struct xpvcv, xcv_file)
#define PVCV_outside_ix	sv_SVp | STRUCT_OFFSET(struct xpvcv, xcv_outside)
#define PVCV_outside_seq_ix sv_U32p | STRUCT_OFFSET(struct xpvcv, xcv_outside_seq)
#define PVCV_flags_ix	sv_U32p | STRUCT_OFFSET(struct xpvcv, xcv_flags)
#define PVHV_max_ix	sv_STRLENp | STRUCT_OFFSET(struct xpvhv, xhv_max)
#if PERL_VERSION > 12
#define PVHV_keys_ix	sv_STRLENp | STRUCT_OFFSET(struct xpvhv, xhv_keys)
#else
#define PVHV_keys_ix	sv_IVp | STRUCT_OFFSET(struct xpvhv, xhv_keys)
#endif

XS_EUPXS(XS_B__IV_IVX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IV_IVX)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__SV	sv;
#line 1651 "B.xs"
	char *ptr;
	SV *ret;
#line 2012 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1654 "B.xs"
	ptr = (ix & 0xFFFF) + (char *)SvANY(sv);
	switch ((U8)(ix >> 16)) {
	case (U8)(sv_SVp >> 16):
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case (U8)(sv_IVp >> 16):
	    ret = sv_2mortal(newSViv(*((IV *)ptr)));
	    break;
	case (U8)(sv_UVp >> 16):
	    ret = sv_2mortal(newSVuv(*((UV *)ptr)));
	    break;
	case (U8)(sv_STRLENp >> 16):
	    ret = sv_2mortal(newSVuv(*((STRLEN *)ptr)));
	    break;
	case (U8)(sv_U32p >> 16):
	    ret = sv_2mortal(newSVuv(*((U32 *)ptr)));
	    break;
	case (U8)(sv_U8p >> 16):
	    ret = sv_2mortal(newSVuv(*((U8 *)ptr)));
	    break;
	case (U8)(sv_char_pp >> 16):
	    ret = sv_2mortal(newSVpv(*((char **)ptr), 0));
	    break;
	case (U8)(sv_NVp >> 16):
	    ret = sv_2mortal(newSVnv(*((NV *)ptr)));
	    break;
	case (U8)(sv_char_p >> 16):
	    ret = newSVpvn_flags((char *)ptr, 1, SVs_TEMP);
	    break;
	case (U8)(sv_SSize_tp >> 16):
	    ret = sv_2mortal(newSViv(*((SSize_t *)ptr)));
	    break;
	case (U8)(sv_I32p >> 16):
	    ret = sv_2mortal(newSVuv(*((I32 *)ptr)));
	    break;
	case (U8)(sv_U16p >> 16):
	    ret = sv_2mortal(newSVuv(*((U16 *)ptr)));
	    break;
	default:
	    croak("Illegal alias 0x%08x for B::*IVX", (unsigned)ix);
	}
	ST(0) = ret;
	XSRETURN(1);
#line 2065 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__IV_packiv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IV_packiv)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1704 "B.xs"
	if (ix) {
	    ST(0) = boolSV((I32)SvIVX(sv) != SvIVX(sv));
	} else if (sizeof(IV) == 8) {
	    U32 wp[2];
	    const IV iv = SvIVX(sv);
	    /*
	     * The following way of spelling 32 is to stop compilers on
	     * 32-bit architectures from moaning about the shift count
	     * being >= the width of the type. Such architectures don't
	     * reach this code anyway (unless sizeof(IV) > 8 but then
	     * everything else breaks too so I'm not fussed at the moment).
	     */
#ifdef UV_IS_QUAD
	    wp[0] = htonl(((UV)iv) >> (sizeof(UV)*4));
#else
	    wp[0] = htonl(((U32)iv) >> (sizeof(UV)*4));
#endif
	    wp[1] = htonl(iv & 0xffffffff);
	    ST(0) = newSVpvn_flags((char *)wp, 8, SVs_TEMP);
	} else {
	    U32 w = htonl((U32)SvIVX(sv));
	    ST(0) = newSVpvn_flags((char *)&w, 4, SVs_TEMP);
	}
#line 2113 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__NV_NV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__NV_NV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	NV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference")
;

	RETVAL = SvNV(sv);
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 11
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_B__RV_RV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__RV_RV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__RV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__RV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1742 "B.xs"
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));
#line 2168 "B.c"
	PUTBACK;
	return;
    }
}

#else
#define XSubPPtmpAAAD 1


XS_EUPXS(XS_B__REGEXP_REGEX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__REGEXP_REGEX)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__REGEXP	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__REGEXP,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1756 "B.xs"
	if (ix == 1) {
	    PUSHs(newSVpvn_flags(RX_PRECOMP(sv), RX_PRELEN(sv), SVs_TEMP));
	} else if (ix == 2) {
	    PUSHs(make_sv_object(aTHX_ (SV *)ReANY(sv)->qr_anoncv));
	} else {
	    dXSTARG;
	    if (ix)
		PUSHu(RX_COMPFLAGS(sv));
	    else
	    /* FIXME - can we code this method more efficiently?  */
		PUSHi(PTR2IV(sv));
	}
#line 2210 "B.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_B__PV_RV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PV_RV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1777 "B.xs"
        if (!SvROK(sv))
            croak( "argument is not SvROK" );
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));
#line 2240 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__PV_PV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PV_PV)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;
#line 1789 "B.xs"
	const char *p;
	STRLEN len = 0;
	U32 utf8 = 0;
#line 2260 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1793 "B.xs"
	if (ix == 3) {
#ifndef PERL_FBM_TABLE_OFFSET
	    const MAGIC *const mg = mg_find(sv, PERL_MAGIC_bm);

	    if (!mg)
                croak("argument to B::BM::TABLE is not a PVBM");
	    p = mg->mg_ptr;
	    len = mg->mg_len;
#else
	    p = SvPV(sv, len);
	    /* Boyer-Moore table is just after string and its safety-margin \0 */
	    p += len + PERL_FBM_TABLE_OFFSET;
	    len = 256;
#endif
	} else if (ix == 2) {
	    /* This used to read 257. I think that that was buggy - should have
	       been 258. (The "\0", the flags byte, and 256 for the table.)
	       The only user of this method is B::Bytecode in B::PV::bsave.
	       I'm guessing that nothing tested the runtime correctness of
	       output of bytecompiled string constant arguments to index (etc).

	       Note the start pointer is and has always been SvPVX(sv), not
	       SvPVX(sv) + SvCUR(sv) PVBM was added in 651aa52ea1faa806, and
	       first used by the compiler in 651aa52ea1faa806. It's used to
	       get a "complete" dump of the buffer at SvPVX(), not just the
	       PVBM table. This permits the generated bytecode to "load"
	       SvPVX in "one" hit.

	       5.15 and later store the BM table via MAGIC, so the compiler
	       should handle this just fine without changes if PVBM now
	       always returns the SvPVX() buffer.  */
#ifdef isREGEXP
	    p = isREGEXP(sv)
		 ? RX_WRAPPED_const((REGEXP*)sv)
		 : SvPVX_const(sv);
#else
	    p = SvPVX_const(sv);
#endif
#ifdef PERL_FBM_TABLE_OFFSET
	    len = SvCUR(sv) + (SvVALID(sv) ? 256 + PERL_FBM_TABLE_OFFSET : 0);
#else
	    len = SvCUR(sv);
#endif
	} else if (ix) {
#ifdef isREGEXP
	    p = isREGEXP(sv) ? RX_WRAPPED((REGEXP*)sv) : SvPVX(sv);
#else
	    p = SvPVX(sv);
#endif
	    len = strlen(p);
	} else if (SvPOK(sv)) {
	    len = SvCUR(sv);
	    p = SvPVX_const(sv);
	    utf8 = SvUTF8(sv);
        }
#ifdef isREGEXP
	else if (isREGEXP(sv)) {
	    len = SvCUR(sv);
	    p = RX_WRAPPED_const((REGEXP*)sv);
	    utf8 = SvUTF8(sv);
	}
#endif
        else {
            /* XXX for backward compatibility, but should fail */
            /* croak( "argument is not SvPOK" ); */
	    p = NULL;
        }
	ST(0) = newSVpvn_flags(p, len, SVs_TEMP | utf8);
#line 2338 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__PVMG_MAGIC); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PVMG_MAGIC)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PVMG	sv;
	MAGIC *	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1869 "B.xs"
	for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic)
	    XPUSHs(make_mg_object(aTHX_ mg));
#line 2366 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__MAGIC_MOREMAGIC); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__MAGIC_MOREMAGIC)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__MAGIC	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference")
;
#line 1887 "B.xs"
	switch (ix) {
	case 0:
	    XPUSHs(mg->mg_moremagic ? make_mg_object(aTHX_ mg->mg_moremagic)
				    : &PL_sv_undef);
	    break;
	case 1:
	    mPUSHu(mg->mg_private);
	    break;
	case 2:
	    PUSHs(newSVpvn_flags(&(mg->mg_type), 1, SVs_TEMP));
	    break;
	case 3:
	    mPUSHu(mg->mg_flags);
	    break;
	case 4:
	    mPUSHi(mg->mg_len);
	    break;
	case 5:
	    PUSHs(make_sv_object(aTHX_ mg->mg_obj));
	    break;
	case 6:
	    if (mg->mg_ptr) {
		if (mg->mg_len >= 0) {
		    PUSHs(newSVpvn_flags(mg->mg_ptr, mg->mg_len, SVs_TEMP));
		} else if (mg->mg_len == HEf_SVKEY) {
		    PUSHs(make_sv_object(aTHX_ (SV*)mg->mg_ptr));
		} else
		    PUSHs(sv_newmortal());
	    } else
		PUSHs(sv_newmortal());
	    break;
	case 7:
	    if(mg->mg_type == PERL_MAGIC_qr) {
                mPUSHi(PTR2IV(mg->mg_obj));
	    } else {
		croak("REGEX is only meaningful on r-magic");
	    }
	    break;
	case 8:
	    if (mg->mg_type == PERL_MAGIC_qr) {
		REGEXP *rx = (REGEXP *)mg->mg_obj;
		PUSHs(newSVpvn_flags(rx ? RX_PRECOMP(rx) : NULL,
				     rx ? RX_PRELEN(rx) : 0, SVs_TEMP));
	    } else {
		croak( "precomp is only meaningful on r-magic" );
	    }
	    break;
	}
#line 2441 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__BM_PREVIOUS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__BM_PREVIOUS)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__BM	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1942 "B.xs"
#if PERL_VERSION >= 19
        PERL_UNUSED_VAR(sv);
#endif
	RETVAL = BmPREVIOUS(sv);
#line 2471 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__BM_RARE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__BM_RARE)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__BM	sv;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1954 "B.xs"
#if PERL_VERSION >= 19
        PERL_UNUSED_VAR(sv);
#endif
	RETVAL = BmRARE(sv);
#line 2501 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__GV_NAME); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_NAME)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;
#line 1971 "B.xs"
	ST(0) = sv_2mortal(newSVhek(!ix ? GvNAME_HEK(gv)
					: (ix == 1 ? GvFILE_HEK(gv)
						   : HvNAME_HEK((HV *)gv))));
#line 2529 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__GV_is_empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_is_empty)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;
#line 1981 "B.xs"
	if (ix) {
	    RETVAL = isGV_with_GP(gv) ? TRUE : FALSE;
	} else {
            RETVAL = GvGP(gv) == Null(GP*);
	}
#line 2559 "B.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__GV_GP); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_GP)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	void *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;

	RETVAL = GvGP(gv);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#define GP_sv_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_sv)
#define GP_io_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_io)
#define GP_cv_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_cv)
#define GP_cvgen_ix	(U32p << 16) | STRUCT_OFFSET(struct gp, gp_cvgen)
#define GP_refcnt_ix	(U32p << 16) | STRUCT_OFFSET(struct gp, gp_refcnt)
#define GP_hv_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_hv)
#define GP_av_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_av)
#define GP_form_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_form)
#define GP_egv_ix	(SVp << 16) | STRUCT_OFFSET(struct gp, gp_egv)

XS_EUPXS(XS_B__GV_SV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_SV)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__GV	gv;
#line 2017 "B.xs"
	GP *gp;
	char *ptr;
	SV *ret;
#line 2616 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;
#line 2021 "B.xs"
	gp = GvGP(gv);
	if (!gp) {
	    const GV *const gv = CvGV(cv);
	    Perl_croak(aTHX_ "NULL gp in B::GV::%s", gv ? GvNAME(gv) : "???");
	}
	ptr = (ix & 0xFFFF) + (char *)gp;
	switch ((U8)(ix >> 16)) {
	case SVp:
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case U32p:
	    ret = sv_2mortal(newSVuv(*((U32*)ptr)));
	    break;
	default:
	    croak("Illegal alias 0x%08x for B::*SV", (unsigned)ix);
	}
	ST(0) = ret;
	XSRETURN(1);
#line 2644 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__GV_LINE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_LINE)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;

	RETVAL = GvLINE(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__GV_GPFLAGS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_GPFLAGS)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;

	RETVAL = GvGPFLAGS(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__GV_FILEGV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_FILEGV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__GV	gv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;
#line 2052 "B.xs"
	PUSHs(make_sv_object(aTHX_ (SV *)GvFILEGV(gv)));
#line 2723 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__IO_IsSTD); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IO_IsSTD)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "io, name");
    {
	B__IO	io;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;
#line 2062 "B.xs"
	PerlIO* handle = 0;
#line 2742 "B.c"
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference")
;
#line 2064 "B.xs"
	if( strEQ( name, "stdin" ) ) {
	    handle = PerlIO_stdin();
	}
	else if( strEQ( name, "stdout" ) ) {
	    handle = PerlIO_stdout();
	}
	else if( strEQ( name, "stderr" ) ) {
	    handle = PerlIO_stderr();
	}
	else {
	    croak( "Invalid value '%s'", name );
	}
	RETVAL = handle == IoIFP(io);
#line 2766 "B.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__AV_FILL); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__AV_FILL)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference")
;

	RETVAL = AvFILL(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__AV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__AV_ARRAY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "av");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__AV	av;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference")
;
#line 2090 "B.xs"
	if (AvFILL(av) >= 0) {
	    SV **svp = AvARRAY(av);
	    I32 i;
	    for (i = 0; i <= AvFILL(av); i++)
		XPUSHs(make_sv_object(aTHX_ svp[i]));
	}
#line 2824 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__AV_ARRAYelt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__AV_ARRAYelt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "av, idx");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__AV	av;
	int	idx = (int)SvIV(ST(1))
;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference")
;
#line 2102 "B.xs"
    	if (idx >= 0 && AvFILL(av) >= 0 && idx <= AvFILL(av))
	    XPUSHs(make_sv_object(aTHX_ (AvARRAY(av)[idx])));
	else
	    XPUSHs(make_sv_object(aTHX_ NULL));
#line 2856 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__FM_LINES); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__FM_LINES)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "format");
    {
	B__FM	format;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    format = INT2PTR(B__FM,tmp);
	}
	else
	    croak("format is not a reference")
;
#line 2114 "B.xs"
        PERL_UNUSED_VAR(format);
       RETVAL = 0;
#line 2884 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__CV_CONST); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_CONST)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;

	RETVAL = CvCONST(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__CV_START); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_START)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 2132 "B.xs"
	PUSHs(make_op_object(aTHX_ CvISXSUB(cv) ? NULL
			     : ix ? CvROOT(cv) : CvSTART(cv)));
#line 2939 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__CV_DEPTH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_DEPTH)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;

	RETVAL = CvDEPTH(cv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef PadlistARRAY
#define XSubPPtmpAAAE 1


XS_EUPXS(XS_B__CV_PADLIST); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_PADLIST)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__PADLIST	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 2145 "B.xs"
	RETVAL = CvISXSUB(cv) ? NULL : CvPADLIST(cv);
#line 2994 "B.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setiv(newSVrv(RETVALSV, RETVAL ? "B::PADLIST" : "B::NULL"),
		     PTR2IV(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAF 1


XS_EUPXS(XS_B__CV_PADLIST); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_PADLIST)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__CV	cv;
	B__AV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 2155 "B.xs"
	PUSHs(make_sv_object(aTHX_ (SV *)CvPADLIST(cv)));
#line 3031 "B.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_B__CV_HSCXT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_HSCXT)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 2164 "B.xs"
	RETVAL = newSVuv(CvISXSUB(cv) ? PTR2UV(CvHSCXT(cv)) : 0);
#line 3058 "B.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__CV_XSUB); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_XSUB)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 2174 "B.xs"
	ST(0) = ix && CvCONST(cv)
	    ? make_sv_object(aTHX_ (SV *)CvXSUBANY(cv).any_ptr)
	    : sv_2mortal(newSViv(CvISXSUB(cv)
				 ? (ix ? CvXSUBANY(cv).any_iv
				       : PTR2IV(CvXSUB(cv)))
				 : 0));
#line 3090 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__CV_const_sv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_const_sv)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 2185 "B.xs"
	PUSHs(make_sv_object(aTHX_ (SV *)cv_const_sv(cv)));
#line 3116 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__CV_GV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_GV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 2191 "B.xs"
	ST(0) = make_sv_object(aTHX_ (SV*)CvGV(cv));
#line 3141 "B.c"
    }
    XSRETURN(1);
}

#if PERL_VERSION > 17
#define XSubPPtmpAAAG 1


XS_EUPXS(XS_B__CV_NAME_HEK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_NAME_HEK)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 2199 "B.xs"
	RETVAL = CvNAMED(cv) ? newSVhek(CvNAME_HEK(cv)) : &PL_sv_undef;
#line 3169 "B.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_B__HV_FILL); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HV_FILL)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference")
;

	RETVAL = HvFILL(hv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__HV_RITER); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HV_RITER)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference")
;

	RETVAL = HvRITER(hv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__HV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HV_ARRAY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__HV	hv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference")
;
#line 2219 "B.xs"
	if (HvUSEDKEYS(hv) > 0) {
	    HE *he;
	    (void)hv_iterinit(hv);
	    EXTEND(sp, HvUSEDKEYS(hv) * 2);
	    while ((he = hv_iternext(hv))) {
                if (HeSVKEY(he)) {
                    mPUSHs(HeSVKEY(he));
                } else if (HeKUTF8(he)) {
                    PUSHs(newSVpvn_flags(HeKEY(he), HeKLEN(he), SVf_UTF8|SVs_TEMP));
                } else {
                    mPUSHp(HeKEY(he), HeKLEN(he));
                }
		PUSHs(make_sv_object(aTHX_ HeVAL(he)));
	    }
	}
#line 3264 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__HE_VAL); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HE_VAL)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "he");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__HE	he;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference")
;
#line 2243 "B.xs"
	PUSHs(make_sv_object(aTHX_ ix ? HeSVKEY_force(he) : HeVAL(he)));
#line 3292 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__HE_HASH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HE_HASH)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "he");
    {
	B__HE	he;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference")
;

	RETVAL = HeHASH(he);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__RHE_HASH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__RHE_HASH)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	B__RHE	h;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    h = INT2PTR(B__RHE,tmp);
	}
	else
	    croak("h is not a reference")
;
#line 2255 "B.xs"
	RETVAL = newRV( (SV*)cophh_2hv(h, 0) );
#line 3344 "B.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}

#ifdef PadlistARRAY
#define XSubPPtmpAAAH 1


XS_EUPXS(XS_B__PADLIST_MAX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADLIST_MAX)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "padlist");
    {
	B__PADLIST	padlist;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    padlist = INT2PTR(B__PADLIST,tmp);
	}
	else
	    croak("padlist is not a reference")
;
#line 2269 "B.xs"
        PERL_UNUSED_VAR(ix);
	RETVAL = PadlistMAX(padlist);
#line 3377 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__PADLIST_NAMES); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADLIST_NAMES)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "padlist");
    {
	B__PADLIST	padlist;
	B__PADNAMELIST	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    padlist = INT2PTR(B__PADLIST,tmp);
	}
	else
	    croak("padlist is not a reference")
;

	RETVAL = PadlistNAMES(padlist);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setiv(newSVrv(RETVALSV, RETVAL ? "B::PADNAMELIST" : "B::NULL"),
		     PTR2IV(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__PADLIST_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADLIST_ARRAY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "padlist");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PADLIST	padlist;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    padlist = INT2PTR(B__PADLIST,tmp);
	}
	else
	    croak("padlist is not a reference")
;
#line 2282 "B.xs"
	if (PadlistMAX(padlist) >= 0) {
	    dXSTARG;
	    PAD **padp = PadlistARRAY(padlist);
            SSize_t i;
	    sv_setiv(newSVrv(TARG, PadlistNAMES(padlist)
				    ? "B::PADNAMELIST"
				    : "B::NULL"),
		     PTR2IV(PadlistNAMES(padlist)));
	    XPUSHTARG;
	    for (i = 1; i <= PadlistMAX(padlist); i++)
		XPUSHs(make_sv_object(aTHX_ (SV *)padp[i]));
	}
#line 3446 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__PADLIST_ARRAYelt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADLIST_ARRAYelt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "padlist, idx");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PADLIST	padlist;
	SSize_t	idx = (SSize_t)SvIV(ST(1))
;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    padlist = INT2PTR(B__PADLIST,tmp);
	}
	else
	    croak("padlist is not a reference")
;
#line 2300 "B.xs"
	if (idx < 0 || idx > PadlistMAX(padlist))
	    XPUSHs(make_sv_object(aTHX_ NULL));
	else if (!idx) {
	    PL_stack_sp--;
	    PUSHMARK(PL_stack_sp-1);
	    XS_B__PADLIST_NAMES(aTHX_ cv);
	    return;
	}
	else
	    XPUSHs(make_sv_object(aTHX_
				  (SV *)PadlistARRAY(padlist)[idx]));
#line 3485 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__PADLIST_REFCNT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADLIST_REFCNT)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "padlist");
    {
	B__PADLIST	padlist;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    padlist = INT2PTR(B__PADLIST,tmp);
	}
	else
	    croak("padlist is not a reference")
;
#line 2316 "B.xs"
        PERL_UNUSED_VAR(padlist);
	RETVAL = PadlistREFCNT(padlist);
#line 3513 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_B__PADNAMELIST_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADNAMELIST_ARRAY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pnl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PADNAMELIST	pnl;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pnl = INT2PTR(B__PADNAMELIST,tmp);
	}
	else
	    croak("pnl is not a reference")
;
#line 2329 "B.xs"
	if (PadnamelistMAX(pnl) >= 0) {
	    PADNAME **padp = PadnamelistARRAY(pnl);
            SSize_t i = 0;
	    for (; i <= PadnamelistMAX(pnl); i++)
	    {
		SV *rv = sv_newmortal();
		sv_setiv(newSVrv(rv,padp[i] ? "B::PADNAME" : "B::SPECIAL"),
			 PTR2IV(padp[i]));
		XPUSHs(rv);
	    }
	}
#line 3551 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__PADNAMELIST_ARRAYelt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADNAMELIST_ARRAYelt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "pnl, idx");
    {
	B__PADNAMELIST	pnl;
	SSize_t	idx = (SSize_t)SvIV(ST(1))
;
	B__PADNAME	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pnl = INT2PTR(B__PADNAMELIST,tmp);
	}
	else
	    croak("pnl is not a reference")
;
#line 2346 "B.xs"
	if (idx < 0 || idx > PadnamelistMAX(pnl))
	    RETVAL = NULL;
	else
	    RETVAL = PadnamelistARRAY(pnl)[idx];
#line 3582 "B.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setiv(newSVrv(RETVALSV, RETVAL ? "B::PADNAME" : "B::SPECIAL"),
		     PTR2IV(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#define PN_type_ix \
	sv_SVp | STRUCT_OFFSET(struct padname,xpadn_type_u.xpadn_typestash)
#define PN_ourstash_ix \
	sv_SVp | STRUCT_OFFSET(struct padname,xpadn_ourstash)
#define PN_len_ix \
	sv_U8p | STRUCT_OFFSET(struct padname,xpadn_len)
#define PN_refcnt_ix \
	sv_U32p | STRUCT_OFFSET(struct padname, xpadn_refcnt)
#define PN_cop_seq_range_low_ix \
	sv_U32p | STRUCT_OFFSET(struct padname, xpadn_low)
#define PN_cop_seq_range_high_ix \
	sv_U32p | STRUCT_OFFSET(struct padname, xpadn_high)
#define PNL_refcnt_ix \
	sv_U32p | STRUCT_OFFSET(struct padnamelist, xpadnl_refcnt)
#define PL_id_ix \
	sv_U32p | STRUCT_OFFSET(struct padlist, xpadl_id)
#define PL_outid_ix \
	sv_U32p | STRUCT_OFFSET(struct padlist, xpadl_outid)

XS_EUPXS(XS_B__PADNAME_TYPE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADNAME_TYPE)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pn");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PADNAME	pn;
#line 2389 "B.xs"
	char *ptr;
	SV *ret;
#line 3627 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pn = INT2PTR(B__PADNAME,tmp);
	}
	else
	    croak("pn is not a reference")
;
#line 2392 "B.xs"
	ptr = (ix & 0xFFFF) + (char *)pn;
	switch ((U8)(ix >> 16)) {
	case (U8)(sv_SVp >> 16):
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case (U8)(sv_U32p >> 16):
	    ret = sv_2mortal(newSVuv(*((U32 *)ptr)));
	    break;
	case (U8)(sv_U8p >> 16):
	    ret = sv_2mortal(newSVuv(*((U8 *)ptr)));
	    break;
	default:
	    NOT_REACHED;
	}
	ST(0) = ret;
	XSRETURN(1);
#line 3653 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__PADNAME_PV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADNAME_PV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pn");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PADNAME	pn;
#line 2413 "B.xs"
	dXSTARG;
#line 3672 "B.c"
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pn = INT2PTR(B__PADNAME,tmp);
	}
	else
	    croak("pn is not a reference")
;
#line 2415 "B.xs"
	PERL_UNUSED_ARG(RETVAL);
	sv_setpvn(TARG, PadnamePV(pn), PadnameLEN(pn));
	SvUTF8_on(TARG);
	XPUSHTARG;
#line 3687 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__PADNAME_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADNAME_FLAGS)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pn");
    {
	B__PADNAME	pn;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pn = INT2PTR(B__PADNAME,tmp);
	}
	else
	    croak("pn is not a reference")
;
#line 2441 "B.xs"
	RETVAL = PadnameFLAGS(pn);
	/* backward-compatibility hack, which should be removed if the
	   flags field becomes large enough to hold SVf_FAKE (and
	   PADNAMEt_OUTER should be renumbered to match SVf_FAKE) */
	STATIC_ASSERT_STMT(SVf_FAKE >= 1<<(sizeof(PadnameFLAGS((B__PADNAME)NULL)) * 8));
	if (PadnameOUTER(pn))
	    RETVAL |= SVf_FAKE;
#line 3720 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_B); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_B)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

#if XSubPPtmpAAAA
        newXS_deffile("B::formfeed", XS_B_formfeed);
#endif
        newXS_deffile("B::amagic_generation", XS_B_amagic_generation);
        newXS_deffile("B::comppadlist", XS_B_comppadlist);
        cv = newXS_deffile("B::sv_no", XS_B_sv_undef);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("B::sv_undef", XS_B_sv_undef);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("B::sv_yes", XS_B_sv_undef);
        XSANY.any_i32 = 2;
        cv = newXS_deffile("B::main_root", XS_B_main_root);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("B::main_start", XS_B_main_root);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("B::dowarn", XS_B_sub_generation);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("B::sub_generation", XS_B_sub_generation);
        XSANY.any_i32 = 0;
        newXS_deffile("B::walkoptree", XS_B_walkoptree);
        newXS_deffile("B::walkoptree_debug", XS_B_walkoptree_debug);
        newXS_deffile("B::address", XS_B_address);
        newXS_deffile("B::svref_2object", XS_B_svref_2object);
        newXS_deffile("B::opnumber", XS_B_opnumber);
        newXS_deffile("B::ppname", XS_B_ppname);
        newXS_deffile("B::hash", XS_B_hash);
        newXS_deffile("B::cast_I32", XS_B_cast_I32);
        cv = newXS_deffile("B::minus_c", XS_B_minus_c);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("B::save_BEGINs", XS_B_minus_c);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("B::cchar", XS_B_cstring);
        XSANY.any_i32 = 2;
        cv = newXS_deffile("B::cstring", XS_B_cstring);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("B::perlstring", XS_B_cstring);
        XSANY.any_i32 = 1;
        newXS_deffile("B::threadsv_names", XS_B_threadsv_names);
#if XSubPPtmpAAAB
        newXS_deffile("B::CLONE", XS_B_CLONE);
#endif
        cv = newXS_deffile("B::BINOP::last", XS_B__OP_next);
        XSANY.any_i32 = 6;
        cv = newXS_deffile("B::COP::arybase", XS_B__OP_next);
        XSANY.any_i32 = 43;
        cv = newXS_deffile("B::COP::cop_seq", XS_B__OP_next);
        XSANY.any_i32 = 17;
        cv = newXS_deffile("B::COP::file", XS_B__OP_next);
        XSANY.any_i32 = 22;
        cv = newXS_deffile("B::COP::filegv", XS_B__OP_next);
        XSANY.any_i32 = 21;
        cv = newXS_deffile("B::COP::hints", XS_B__OP_next);
        XSANY.any_i32 = 19;
        cv = newXS_deffile("B::COP::hints_hash", XS_B__OP_next);
        XSANY.any_i32 = 46;
        cv = newXS_deffile("B::COP::io", XS_B__OP_next);
        XSANY.any_i32 = 45;
        cv = newXS_deffile("B::COP::label", XS_B__OP_next);
        XSANY.any_i32 = 42;
        cv = newXS_deffile("B::COP::line", XS_B__OP_next);
        XSANY.any_i32 = 18;
        cv = newXS_deffile("B::COP::stash", XS_B__OP_next);
        XSANY.any_i32 = 23;
        cv = newXS_deffile("B::COP::stashoff", XS_B__OP_next);
        XSANY.any_i32 = 25;
        cv = newXS_deffile("B::COP::stashpv", XS_B__OP_next);
        XSANY.any_i32 = 24;
        cv = newXS_deffile("B::COP::warnings", XS_B__OP_next);
        XSANY.any_i32 = 44;
        cv = newXS_deffile("B::LISTOP::children", XS_B__OP_next);
        XSANY.any_i32 = 33;
        cv = newXS_deffile("B::LOGOP::other", XS_B__OP_next);
        XSANY.any_i32 = 7;
        cv = newXS_deffile("B::LOOP::lastop", XS_B__OP_next);
        XSANY.any_i32 = 11;
        cv = newXS_deffile("B::LOOP::nextop", XS_B__OP_next);
        XSANY.any_i32 = 10;
        cv = newXS_deffile("B::LOOP::redoop", XS_B__OP_next);
        XSANY.any_i32 = 9;
        cv = newXS_deffile("B::METHOP::first", XS_B__OP_next);
        XSANY.any_i32 = 53;
        cv = newXS_deffile("B::METHOP::meth_sv", XS_B__OP_next);
        XSANY.any_i32 = 54;
        cv = newXS_deffile("B::METHOP::rclass", XS_B__OP_next);
        XSANY.any_i32 = 56;
        cv = newXS_deffile("B::OP::desc", XS_B__OP_next);
        XSANY.any_i32 = 28;
        cv = newXS_deffile("B::OP::flags", XS_B__OP_next);
        XSANY.any_i32 = 3;
        cv = newXS_deffile("B::OP::folded", XS_B__OP_next);
        XSANY.any_i32 = 50;
        cv = newXS_deffile("B::OP::moresib", XS_B__OP_next);
        XSANY.any_i32 = 51;
        cv = newXS_deffile("B::OP::name", XS_B__OP_next);
        XSANY.any_i32 = 27;
        cv = newXS_deffile("B::OP::next", XS_B__OP_next);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("B::OP::opt", XS_B__OP_next);
        XSANY.any_i32 = 31;
        cv = newXS_deffile("B::OP::parent", XS_B__OP_next);
        XSANY.any_i32 = 52;
        cv = newXS_deffile("B::OP::ppaddr", XS_B__OP_next);
        XSANY.any_i32 = 29;
        cv = newXS_deffile("B::OP::private", XS_B__OP_next);
        XSANY.any_i32 = 4;
        cv = newXS_deffile("B::OP::savefree", XS_B__OP_next);
        XSANY.any_i32 = 48;
        cv = newXS_deffile("B::OP::sibling", XS_B__OP_next);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("B::OP::size", XS_B__OP_next);
        XSANY.any_i32 = 26;
        cv = newXS_deffile("B::OP::slabbed", XS_B__OP_next);
        XSANY.any_i32 = 47;
        cv = newXS_deffile("B::OP::spare", XS_B__OP_next);
        XSANY.any_i32 = 32;
        cv = newXS_deffile("B::OP::static", XS_B__OP_next);
        XSANY.any_i32 = 49;
        cv = newXS_deffile("B::OP::targ", XS_B__OP_next);
        XSANY.any_i32 = 2;
        cv = newXS_deffile("B::OP::type", XS_B__OP_next);
        XSANY.any_i32 = 30;
        cv = newXS_deffile("B::PADOP::gv", XS_B__OP_next);
        XSANY.any_i32 = 40;
        cv = newXS_deffile("B::PADOP::padix", XS_B__OP_next);
        XSANY.any_i32 = 16;
        cv = newXS_deffile("B::PADOP::sv", XS_B__OP_next);
        XSANY.any_i32 = 39;
        cv = newXS_deffile("B::PMOP::code_list", XS_B__OP_next);
        XSANY.any_i32 = 13;
        cv = newXS_deffile("B::PMOP::pmflags", XS_B__OP_next);
        XSANY.any_i32 = 12;
        cv = newXS_deffile("B::PMOP::pmoffset", XS_B__OP_next);
        XSANY.any_i32 = 20;
        cv = newXS_deffile("B::PMOP::pmregexp", XS_B__OP_next);
        XSANY.any_i32 = 55;
        cv = newXS_deffile("B::PMOP::pmreplroot", XS_B__OP_next);
        XSANY.any_i32 = 34;
        cv = newXS_deffile("B::PMOP::pmreplstart", XS_B__OP_next);
        XSANY.any_i32 = 8;
        cv = newXS_deffile("B::PMOP::pmstash", XS_B__OP_next);
        XSANY.any_i32 = 36;
        cv = newXS_deffile("B::PMOP::pmstashpv", XS_B__OP_next);
        XSANY.any_i32 = 35;
        cv = newXS_deffile("B::PMOP::precomp", XS_B__OP_next);
        XSANY.any_i32 = 37;
        cv = newXS_deffile("B::PMOP::reflags", XS_B__OP_next);
        XSANY.any_i32 = 38;
        cv = newXS_deffile("B::PVOP::pv", XS_B__OP_next);
        XSANY.any_i32 = 41;
        cv = newXS_deffile("B::SVOP::gv", XS_B__OP_next);
        XSANY.any_i32 = 15;
        cv = newXS_deffile("B::SVOP::sv", XS_B__OP_next);
        XSANY.any_i32 = 14;
        cv = newXS_deffile("B::UNOP::first", XS_B__OP_next);
        XSANY.any_i32 = 5;
        newXS_deffile("B::OP::oplist", XS_B__OP_oplist);
        newXS_deffile("B::UNOP_AUX::string", XS_B__UNOP_AUX_string);
        newXS_deffile("B::UNOP_AUX::aux_list", XS_B__UNOP_AUX_aux_list);
        cv = newXS_deffile("B::SV::FLAGS", XS_B__SV_REFCNT);
        XSANY.any_i32 = 0xFFFFFFFF;
        cv = newXS_deffile("B::SV::MAGICAL", XS_B__SV_REFCNT);
        XSANY.any_i32 = MAGICAL_FLAG_BITS;
        cv = newXS_deffile("B::SV::POK", XS_B__SV_REFCNT);
        XSANY.any_i32 = SVf_POK;
        cv = newXS_deffile("B::SV::REFCNT", XS_B__SV_REFCNT);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("B::SV::ROK", XS_B__SV_REFCNT);
        XSANY.any_i32 = SVf_ROK;
        cv = newXS_deffile("B::SV::SvTYPE", XS_B__SV_REFCNT);
        XSANY.any_i32 = SVTYPEMASK;
        newXS_deffile("B::SV::object_2svref", XS_B__SV_object_2svref);
        newXS_deffile("B::IV::IV", XS_B__IV_IV);
        cv = newXS_deffile("B::AV::MAX", XS_B__IV_IVX);
        XSANY.any_i32 = PVAV_max_ix;
        cv = newXS_deffile("B::BM::USEFUL", XS_B__IV_IVX);
        XSANY.any_i32 = PVBM_useful_ix;
        cv = newXS_deffile("B::CV::CvFLAGS", XS_B__IV_IVX);
        XSANY.any_i32 = PVCV_flags_ix;
        cv = newXS_deffile("B::CV::FILE", XS_B__IV_IVX);
        XSANY.any_i32 = PVCV_file_ix;
        cv = newXS_deffile("B::CV::OUTSIDE", XS_B__IV_IVX);
        XSANY.any_i32 = PVCV_outside_ix;
        cv = newXS_deffile("B::CV::OUTSIDE_SEQ", XS_B__IV_IVX);
        XSANY.any_i32 = PVCV_outside_seq_ix;
        cv = newXS_deffile("B::CV::STASH", XS_B__IV_IVX);
        XSANY.any_i32 = PVCV_stash_ix;
        cv = newXS_deffile("B::GV::GvFLAGS", XS_B__IV_IVX);
        XSANY.any_i32 = PVGV_flags_ix;
        cv = newXS_deffile("B::GV::STASH", XS_B__IV_IVX);
        XSANY.any_i32 = PVGV_stash_ix;
        cv = newXS_deffile("B::HV::KEYS", XS_B__IV_IVX);
        XSANY.any_i32 = PVHV_keys_ix;
        cv = newXS_deffile("B::HV::MAX", XS_B__IV_IVX);
        XSANY.any_i32 = PVHV_max_ix;
        cv = newXS_deffile("B::IO::BOTTOM_GV", XS_B__IV_IVX);
        XSANY.any_i32 = PVIO_bottom_gv_ix;
        cv = newXS_deffile("B::IO::BOTTOM_NAME", XS_B__IV_IVX);
        XSANY.any_i32 = PVIO_bottom_name_ix;
        cv = newXS_deffile("B::IO::FMT_GV", XS_B__IV_IVX);
        XSANY.any_i32 = PVIO_fmt_gv_ix;
        cv = newXS_deffile("B::IO::FMT_NAME", XS_B__IV_IVX);
        XSANY.any_i32 = PVIO_fmt_name_ix;
        cv = newXS_deffile("B::IO::IoFLAGS", XS_B__IV_IVX);
        XSANY.any_i32 = PVIO_flags_ix;
        cv = newXS_deffile("B::IO::IoTYPE", XS_B__IV_IVX);
        XSANY.any_i32 = PVIO_type_ix;
        cv = newXS_deffile("B::IO::LINES", XS_B__IV_IVX);
        XSANY.any_i32 = PVIO_lines_ix;
        cv = newXS_deffile("B::IO::LINES_LEFT", XS_B__IV_IVX);
        XSANY.any_i32 = PVIO_lines_left_ix;
        cv = newXS_deffile("B::IO::PAGE", XS_B__IV_IVX);
        XSANY.any_i32 = PVIO_page_ix;
        cv = newXS_deffile("B::IO::PAGE_LEN", XS_B__IV_IVX);
        XSANY.any_i32 = PVIO_page_len_ix;
        cv = newXS_deffile("B::IO::TOP_GV", XS_B__IV_IVX);
        XSANY.any_i32 = PVIO_top_gv_ix;
        cv = newXS_deffile("B::IO::TOP_NAME", XS_B__IV_IVX);
        XSANY.any_i32 = PVIO_top_name_ix;
        cv = newXS_deffile("B::IV::IVX", XS_B__IV_IVX);
        XSANY.any_i32 = IV_ivx_ix;
        cv = newXS_deffile("B::IV::UVX", XS_B__IV_IVX);
        XSANY.any_i32 = IV_uvx_ix;
        cv = newXS_deffile("B::NV::NVX", XS_B__IV_IVX);
        XSANY.any_i32 = NV_nvx_ix;
        cv = newXS_deffile("B::PV::CUR", XS_B__IV_IVX);
        XSANY.any_i32 = PV_cur_ix;
        cv = newXS_deffile("B::PV::LEN", XS_B__IV_IVX);
        XSANY.any_i32 = PV_len_ix;
        cv = newXS_deffile("B::PVLV::TARG", XS_B__IV_IVX);
        XSANY.any_i32 = PVLV_targ_ix;
        cv = newXS_deffile("B::PVLV::TARGLEN", XS_B__IV_IVX);
        XSANY.any_i32 = PVLV_targlen_ix;
        cv = newXS_deffile("B::PVLV::TARGOFF", XS_B__IV_IVX);
        XSANY.any_i32 = PVLV_targoff_ix;
        cv = newXS_deffile("B::PVLV::TYPE", XS_B__IV_IVX);
        XSANY.any_i32 = PVLV_type_ix;
        cv = newXS_deffile("B::PVMG::SvSTASH", XS_B__IV_IVX);
        XSANY.any_i32 = PVMG_stash_ix;
        cv = newXS_deffile("B::IV::needs64bits", XS_B__IV_packiv);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("B::IV::packiv", XS_B__IV_packiv);
        XSANY.any_i32 = 0;
        newXS_deffile("B::NV::NV", XS_B__NV_NV);
#if XSubPPtmpAAAC
        newXS_deffile("B::RV::RV", XS_B__RV_RV);
#endif
#if XSubPPtmpAAAD
        cv = newXS_deffile("B::REGEXP::REGEX", XS_B__REGEXP_REGEX);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("B::REGEXP::compflags", XS_B__REGEXP_REGEX);
        XSANY.any_i32 = 3;
        cv = newXS_deffile("B::REGEXP::precomp", XS_B__REGEXP_REGEX);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("B::REGEXP::qr_anoncv", XS_B__REGEXP_REGEX);
        XSANY.any_i32 = 2;
#endif
        newXS_deffile("B::PV::RV", XS_B__PV_RV);
        cv = newXS_deffile("B::BM::TABLE", XS_B__PV_PV);
        XSANY.any_i32 = 3;
        cv = newXS_deffile("B::PV::PV", XS_B__PV_PV);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("B::PV::PVBM", XS_B__PV_PV);
        XSANY.any_i32 = 2;
        cv = newXS_deffile("B::PV::PVX", XS_B__PV_PV);
        XSANY.any_i32 = 1;
        newXS_deffile("B::PVMG::MAGIC", XS_B__PVMG_MAGIC);
        cv = newXS_deffile("B::MAGIC::FLAGS", XS_B__MAGIC_MOREMAGIC);
        XSANY.any_i32 = 3;
        cv = newXS_deffile("B::MAGIC::LENGTH", XS_B__MAGIC_MOREMAGIC);
        XSANY.any_i32 = 4;
        cv = newXS_deffile("B::MAGIC::MOREMAGIC", XS_B__MAGIC_MOREMAGIC);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("B::MAGIC::OBJ", XS_B__MAGIC_MOREMAGIC);
        XSANY.any_i32 = 5;
        cv = newXS_deffile("B::MAGIC::PRIVATE", XS_B__MAGIC_MOREMAGIC);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("B::MAGIC::PTR", XS_B__MAGIC_MOREMAGIC);
        XSANY.any_i32 = 6;
        cv = newXS_deffile("B::MAGIC::REGEX", XS_B__MAGIC_MOREMAGIC);
        XSANY.any_i32 = 7;
        cv = newXS_deffile("B::MAGIC::TYPE", XS_B__MAGIC_MOREMAGIC);
        XSANY.any_i32 = 2;
        cv = newXS_deffile("B::MAGIC::precomp", XS_B__MAGIC_MOREMAGIC);
        XSANY.any_i32 = 8;
        newXS_deffile("B::BM::PREVIOUS", XS_B__BM_PREVIOUS);
        newXS_deffile("B::BM::RARE", XS_B__BM_RARE);
        cv = newXS_deffile("B::GV::FILE", XS_B__GV_NAME);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("B::GV::NAME", XS_B__GV_NAME);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("B::HV::NAME", XS_B__GV_NAME);
        XSANY.any_i32 = 2;
        cv = newXS_deffile("B::GV::isGV_with_GP", XS_B__GV_is_empty);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("B::GV::is_empty", XS_B__GV_is_empty);
        XSANY.any_i32 = 0;
        newXS_deffile("B::GV::GP", XS_B__GV_GP);
        cv = newXS_deffile("B::GV::AV", XS_B__GV_SV);
        XSANY.any_i32 = GP_av_ix;
        cv = newXS_deffile("B::GV::CV", XS_B__GV_SV);
        XSANY.any_i32 = GP_cv_ix;
        cv = newXS_deffile("B::GV::CVGEN", XS_B__GV_SV);
        XSANY.any_i32 = GP_cvgen_ix;
        cv = newXS_deffile("B::GV::EGV", XS_B__GV_SV);
        XSANY.any_i32 = GP_egv_ix;
        cv = newXS_deffile("B::GV::FORM", XS_B__GV_SV);
        XSANY.any_i32 = GP_form_ix;
        cv = newXS_deffile("B::GV::GvREFCNT", XS_B__GV_SV);
        XSANY.any_i32 = GP_refcnt_ix;
        cv = newXS_deffile("B::GV::HV", XS_B__GV_SV);
        XSANY.any_i32 = GP_hv_ix;
        cv = newXS_deffile("B::GV::IO", XS_B__GV_SV);
        XSANY.any_i32 = GP_io_ix;
        cv = newXS_deffile("B::GV::SV", XS_B__GV_SV);
        XSANY.any_i32 = GP_sv_ix;
        newXS_deffile("B::GV::LINE", XS_B__GV_LINE);
        newXS_deffile("B::GV::GPFLAGS", XS_B__GV_GPFLAGS);
        newXS_deffile("B::GV::FILEGV", XS_B__GV_FILEGV);
        newXS_deffile("B::IO::IsSTD", XS_B__IO_IsSTD);
        newXS_deffile("B::AV::FILL", XS_B__AV_FILL);
        newXS_deffile("B::AV::ARRAY", XS_B__AV_ARRAY);
        newXS_deffile("B::AV::ARRAYelt", XS_B__AV_ARRAYelt);
        newXS_deffile("B::FM::LINES", XS_B__FM_LINES);
        newXS_deffile("B::CV::CONST", XS_B__CV_CONST);
        cv = newXS_deffile("B::CV::ROOT", XS_B__CV_START);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("B::CV::START", XS_B__CV_START);
        XSANY.any_i32 = 0;
        newXS_deffile("B::CV::DEPTH", XS_B__CV_DEPTH);
#if XSubPPtmpAAAE
        newXS_deffile("B::CV::PADLIST", XS_B__CV_PADLIST);
#endif
#if XSubPPtmpAAAF
        newXS_deffile("B::CV::PADLIST", XS_B__CV_PADLIST);
#endif
        newXS_deffile("B::CV::HSCXT", XS_B__CV_HSCXT);
        cv = newXS_deffile("B::CV::XSUB", XS_B__CV_XSUB);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("B::CV::XSUBANY", XS_B__CV_XSUB);
        XSANY.any_i32 = 1;
        newXS_deffile("B::CV::const_sv", XS_B__CV_const_sv);
        newXS_deffile("B::CV::GV", XS_B__CV_GV);
#if XSubPPtmpAAAG
        newXS_deffile("B::CV::NAME_HEK", XS_B__CV_NAME_HEK);
#endif
        newXS_deffile("B::HV::FILL", XS_B__HV_FILL);
        newXS_deffile("B::HV::RITER", XS_B__HV_RITER);
        newXS_deffile("B::HV::ARRAY", XS_B__HV_ARRAY);
        cv = newXS_deffile("B::HE::SVKEY_force", XS_B__HE_VAL);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("B::HE::VAL", XS_B__HE_VAL);
        XSANY.any_i32 = 0;
        newXS_deffile("B::HE::HASH", XS_B__HE_HASH);
        newXS_deffile("B::RHE::HASH", XS_B__RHE_HASH);
#if XSubPPtmpAAAH
        cv = newXS_deffile("B::PADLIST::MAX", XS_B__PADLIST_MAX);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("B::PADNAMELIST::MAX", XS_B__PADLIST_MAX);
        XSANY.any_i32 = 0;
        newXS_deffile("B::PADLIST::NAMES", XS_B__PADLIST_NAMES);
        newXS_deffile("B::PADLIST::ARRAY", XS_B__PADLIST_ARRAY);
        newXS_deffile("B::PADLIST::ARRAYelt", XS_B__PADLIST_ARRAYelt);
        newXS_deffile("B::PADLIST::REFCNT", XS_B__PADLIST_REFCNT);
#endif
        newXS_deffile("B::PADNAMELIST::ARRAY", XS_B__PADNAMELIST_ARRAY);
        newXS_deffile("B::PADNAMELIST::ARRAYelt", XS_B__PADNAMELIST_ARRAYelt);
        cv = newXS_deffile("B::PADLIST::id", XS_B__PADNAME_TYPE);
        XSANY.any_i32 = PL_id_ix;
        cv = newXS_deffile("B::PADLIST::outid", XS_B__PADNAME_TYPE);
        XSANY.any_i32 = PL_outid_ix;
        cv = newXS_deffile("B::PADNAME::COP_SEQ_RANGE_HIGH", XS_B__PADNAME_TYPE);
        XSANY.any_i32 = PN_cop_seq_range_high_ix;
        cv = newXS_deffile("B::PADNAME::COP_SEQ_RANGE_LOW", XS_B__PADNAME_TYPE);
        XSANY.any_i32 = PN_cop_seq_range_low_ix;
        cv = newXS_deffile("B::PADNAME::LEN", XS_B__PADNAME_TYPE);
        XSANY.any_i32 = PN_len_ix;
        cv = newXS_deffile("B::PADNAME::OURSTASH", XS_B__PADNAME_TYPE);
        XSANY.any_i32 = PN_ourstash_ix;
        cv = newXS_deffile("B::PADNAME::REFCNT", XS_B__PADNAME_TYPE);
        XSANY.any_i32 = PN_refcnt_ix;
        cv = newXS_deffile("B::PADNAME::TYPE", XS_B__PADNAME_TYPE);
        XSANY.any_i32 = PN_type_ix;
        cv = newXS_deffile("B::PADNAMELIST::REFCNT", XS_B__PADNAME_TYPE);
        XSANY.any_i32 = PNL_refcnt_ix;
        newXS_deffile("B::PADNAME::PV", XS_B__PADNAME_PV);
        newXS_deffile("B::PADNAME::FLAGS", XS_B__PADNAME_FLAGS);

    /* Initialisation Section */

#line 2 "./const-xs.inc"
  {
#ifdef dTHX
    dTHX;
#endif
    HV *symbol_table = get_hv("B::", GV_ADD);
    AV *push = get_av("B::EXPORT_OK", GV_ADD);
    HE *he;

    static const struct iv_s values_for_iv[] =
      {
        { "HEf_SVKEY", 9, HEf_SVKEY },
        { NULL, 0, 0 } };
	const struct iv_s *value_for_iv = values_for_iv;

    static const struct uv_s values_for_uv[] =
      {
        { "SVTYPEMASK", 10, SVTYPEMASK },
        { "SVt_PVGV", 8, SVt_PVGV },
        { "SVt_PVHV", 8, SVt_PVHV },
        { "PAD_FAKELEX_ANON", 16, PAD_FAKELEX_ANON },
        { "PAD_FAKELEX_MULTI", 17, PAD_FAKELEX_MULTI },
        { "SVpad_STATE", 11, SVpad_STATE },
        { "SVpad_TYPED", 11, SVpad_TYPED },
        { "SVpad_OUR", 9, SVpad_OUR },
        { "CxPOPSUB_DONE", 13, CxPOPSUB_DONE },
        { "CXTYPEMASK", 10, CXTYPEMASK },
        { "CXt_NULL", 8, CXt_NULL },
        { "CXt_WHEN", 8, CXt_WHEN },
        { "CXt_BLOCK", 9, CXt_BLOCK },
        { "CXt_GIVEN", 9, CXt_GIVEN },
        { "CXt_LOOP_FOR", 12, CXt_LOOP_FOR },
        { "CXt_LOOP_PLAIN", 14, CXt_LOOP_PLAIN },
        { "CXt_LOOP_LAZYSV", 15, CXt_LOOP_LAZYSV },
        { "CXt_LOOP_LAZYIV", 15, CXt_LOOP_LAZYIV },
        { "CXt_SUB", 7, CXt_SUB },
        { "CXt_FORMAT", 10, CXt_FORMAT },
        { "CXt_EVAL", 8, CXt_EVAL },
        { "CXt_SUBST", 9, CXt_SUBST },
        { "CXp_MULTICALL", 13, CXp_MULTICALL },
        { "CXp_HASARGS", 11, CXp_HASARGS },
        { "CXp_SUB_RE", 10, CXp_SUB_RE },
        { "CXp_SUB_RE_FAKE", 15, CXp_SUB_RE_FAKE },
        { "CXp_REAL", 8, CXp_REAL },
        { "CXp_TRYBLOCK", 12, CXp_TRYBLOCK },
        { "CXp_FOR_DEF", 11, CXp_FOR_DEF },
        { "CXp_FOR_LVREF", 13, CXp_FOR_LVREF },
        { "CXp_ONCE", 8, CXp_ONCE },
        { "G_SCALAR", 8, G_SCALAR },
        { "G_ARRAY", 7, G_ARRAY },
        { "G_VOID", 6, G_VOID },
        { "G_WANT", 6, G_WANT },
        { "G_DISCARD", 9, G_DISCARD },
        { "G_EVAL", 6, G_EVAL },
        { "G_NOARGS", 8, G_NOARGS },
        { "G_KEEPERR", 9, G_KEEPERR },
        { "G_NODEBUG", 9, G_NODEBUG },
        { "G_METHOD", 8, G_METHOD },
        { "G_FAKINGEVAL", 12, G_FAKINGEVAL },
        { "G_UNDEF_FILL", 12, G_UNDEF_FILL },
        { "G_WRITING_TO_STDERR", 19, G_WRITING_TO_STDERR },
        { "G_RE_REPARSING", 14, G_RE_REPARSING },
        { "G_METHOD_NAMED", 14, G_METHOD_NAMED },
        { "EVAL_NULL", 9, EVAL_NULL },
        { "EVAL_INEVAL", 11, EVAL_INEVAL },
        { "EVAL_WARNONLY", 13, EVAL_WARNONLY },
        { "EVAL_KEEPERR", 12, EVAL_KEEPERR },
        { "EVAL_INREQUIRE", 14, EVAL_INREQUIRE },
        { "EVAL_RE_REPARSING", 17, EVAL_RE_REPARSING },
        { "PERLSI_UNDEF", 12, PERLSI_UNDEF },
        { "PERLSI_MAIN", 11, PERLSI_MAIN },
        { "PERLSI_MAGIC", 12, PERLSI_MAGIC },
        { "PERLSI_SORT", 11, PERLSI_SORT },
        { "PERLSI_SIGNAL", 13, PERLSI_SIGNAL },
        { "PERLSI_OVERLOAD", 15, PERLSI_OVERLOAD },
        { "PERLSI_DESTROY", 14, PERLSI_DESTROY },
        { "PERLSI_WARNHOOK", 15, PERLSI_WARNHOOK },
        { "PERLSI_DIEHOOK", 14, PERLSI_DIEHOOK },
        { "PERLSI_REQUIRE", 14, PERLSI_REQUIRE },
        { "CVf_METHOD", 10, CVf_METHOD },
        { "CVf_LVALUE", 10, CVf_LVALUE },
        { "CVf_CONST", 9, CVf_CONST },
        { "CVf_ISXSUB", 10, CVf_ISXSUB },
        { "CVf_WEAKOUTSIDE", 15, CVf_WEAKOUTSIDE },
        { "CVf_CLONE", 9, CVf_CLONE },
        { "CVf_CLONED", 10, CVf_CLONED },
        { "CVf_ANON", 8, CVf_ANON },
        { "CVf_UNIQUE", 10, CVf_UNIQUE },
        { "CVf_NODEBUG", 11, CVf_NODEBUG },
        { "CVf_CVGV_RC", 11, CVf_CVGV_RC },
        { "CVf_DYNFILE", 11, CVf_DYNFILE },
        { "CVf_AUTOLOAD", 12, CVf_AUTOLOAD },
        { "CVf_HASEVAL", 11, CVf_HASEVAL },
        { "CVf_NAMED", 9, CVf_NAMED },
        { "CVf_LEXICAL", 11, CVf_LEXICAL },
        { "CVf_ANONCONST", 13, CVf_ANONCONST },
        { "GVf_INTRO", 9, GVf_INTRO },
        { "GVf_MULTI", 9, GVf_MULTI },
        { "GVf_ASSUMECV", 12, GVf_ASSUMECV },
        { "GVf_IMPORTED", 12, GVf_IMPORTED },
        { "GVf_IMPORTED_SV", 15, GVf_IMPORTED_SV },
        { "GVf_IMPORTED_AV", 15, GVf_IMPORTED_AV },
        { "GVf_IMPORTED_HV", 15, GVf_IMPORTED_HV },
        { "GVf_IMPORTED_CV", 15, GVf_IMPORTED_CV },
        { "GPf_ALIASED_SV", 14, GPf_ALIASED_SV },
        { "OPf_WANT", 8, OPf_WANT },
        { "OPf_WANT_VOID", 13, OPf_WANT_VOID },
        { "OPf_WANT_SCALAR", 15, OPf_WANT_SCALAR },
        { "OPf_WANT_LIST", 13, OPf_WANT_LIST },
        { "OPf_KIDS", 8, OPf_KIDS },
        { "OPf_PARENS", 10, OPf_PARENS },
        { "OPf_REF", 7, OPf_REF },
        { "OPf_MOD", 7, OPf_MOD },
        { "OPf_STACKED", 11, OPf_STACKED },
        { "OPf_SPECIAL", 11, OPf_SPECIAL },
        { "OPf_FOLDED", 10, OPf_FOLDED },
        { "PMf_RETAINT", 11, PMf_RETAINT },
        { "PMf_ONCE", 8, PMf_ONCE },
        { "PMf_USED", 8, PMf_USED },
        { "PMf_CONST", 9, PMf_CONST },
        { "PMf_KEEP", 8, PMf_KEEP },
        { "PMf_GLOBAL", 10, PMf_GLOBAL },
        { "PMf_CONTINUE", 12, PMf_CONTINUE },
        { "PMf_EVAL", 8, PMf_EVAL },
        { "PMf_NONDESTRUCT", 15, PMf_NONDESTRUCT },
        { "PMf_HAS_CV", 10, PMf_HAS_CV },
        { "PMf_CODELIST_PRIVATE", 20, PMf_CODELIST_PRIVATE },
        { "PMf_IS_QR", 9, PMf_IS_QR },
        { "PMf_USE_RE_EVAL", 15, PMf_USE_RE_EVAL },
        { "OA_MARK", 7, OA_MARK },
        { "OA_FOLDCONST", 12, OA_FOLDCONST },
        { "OA_RETSCALAR", 12, OA_RETSCALAR },
        { "OA_TARGET", 9, OA_TARGET },
        { "OA_TARGLEX", 10, OA_TARGLEX },
        { "OA_OTHERINT", 11, OA_OTHERINT },
        { "OA_DANGEROUS", 12, OA_DANGEROUS },
        { "OA_DEFGV", 8, OA_DEFGV },
        { "OCSHIFT", 7, OCSHIFT },
        { "OA_CLASS_MASK", 13, OA_CLASS_MASK },
        { "OA_BASEOP", 9, OA_BASEOP },
        { "OA_UNOP", 7, OA_UNOP },
        { "OA_BINOP", 8, OA_BINOP },
        { "OA_LOGOP", 8, OA_LOGOP },
        { "OA_LISTOP", 9, OA_LISTOP },
        { "OA_PMOP", 7, OA_PMOP },
        { "OA_SVOP", 7, OA_SVOP },
        { "OA_PADOP", 8, OA_PADOP },
        { "OA_PVOP_OR_SVOP", 15, OA_PVOP_OR_SVOP },
        { "OA_LOOP", 7, OA_LOOP },
        { "OA_COP", 6, OA_COP },
        { "OA_BASEOP_OR_UNOP", 17, OA_BASEOP_OR_UNOP },
        { "OA_FILESTATOP", 13, OA_FILESTATOP },
        { "OA_LOOPEXOP", 11, OA_LOOPEXOP },
        { "OA_METHOP", 9, OA_METHOP },
        { "OA_UNOP_AUX", 11, OA_UNOP_AUX },
        { "OASHIFT", 7, OASHIFT },
        { "OA_SCALAR", 9, OA_SCALAR },
        { "OA_LIST", 7, OA_LIST },
        { "OA_AVREF", 8, OA_AVREF },
        { "OA_HVREF", 8, OA_HVREF },
        { "OA_CVREF", 8, OA_CVREF },
        { "OA_FILEREF", 10, OA_FILEREF },
        { "OA_SCALARREF", 12, OA_SCALARREF },
        { "OA_OPTIONAL", 11, OA_OPTIONAL },
        { "PERL_LOADMOD_DENY", 17, PERL_LOADMOD_DENY },
        { "PERL_LOADMOD_NOIMPORT", 21, PERL_LOADMOD_NOIMPORT },
        { "PERL_LOADMOD_IMPORT_OPS", 23, PERL_LOADMOD_IMPORT_OPS },
        { "BHKf_bhk_start", 14, BHKf_bhk_start },
        { "BHKf_bhk_pre_end", 16, BHKf_bhk_pre_end },
        { "BHKf_bhk_post_end", 17, BHKf_bhk_post_end },
        { "BHKf_bhk_eval", 13, BHKf_bhk_eval },
        { "RV2CVOPCV_MARK_EARLY", 20, RV2CVOPCV_MARK_EARLY },
        { "RV2CVOPCV_RETURN_NAME_GV", 24, RV2CVOPCV_RETURN_NAME_GV },
        { "RV2CVOPCV_RETURN_STUB", 21, RV2CVOPCV_RETURN_STUB },
        { "RV2CVOPCV_FLAG_MASK", 19, RV2CVOPCV_FLAG_MASK },
        { "OP_LVALUE_NO_CROAK", 18, OP_LVALUE_NO_CROAK },
        { "XOPf_xop_name", 13, XOPf_xop_name },
        { "XOPf_xop_desc", 13, XOPf_xop_desc },
        { "XOPf_xop_class", 14, XOPf_xop_class },
        { "XOPf_xop_peep", 13, XOPf_xop_peep },
        { "MDEREF_reload", 13, MDEREF_reload },
        { "MDEREF_AV_pop_rv2av_aelem", 25, MDEREF_AV_pop_rv2av_aelem },
        { "MDEREF_AV_gvsv_vivify_rv2av_aelem", 33, MDEREF_AV_gvsv_vivify_rv2av_aelem },
        { "MDEREF_AV_padsv_vivify_rv2av_aelem", 34, MDEREF_AV_padsv_vivify_rv2av_aelem },
        { "MDEREF_AV_vivify_rv2av_aelem", 28, MDEREF_AV_vivify_rv2av_aelem },
        { "MDEREF_AV_padav_aelem", 21, MDEREF_AV_padav_aelem },
        { "MDEREF_AV_gvav_aelem", 20, MDEREF_AV_gvav_aelem },
        { "MDEREF_HV_pop_rv2hv_helem", 25, MDEREF_HV_pop_rv2hv_helem },
        { "MDEREF_HV_gvsv_vivify_rv2hv_helem", 33, MDEREF_HV_gvsv_vivify_rv2hv_helem },
        { "MDEREF_HV_padsv_vivify_rv2hv_helem", 34, MDEREF_HV_padsv_vivify_rv2hv_helem },
        { "MDEREF_HV_vivify_rv2hv_helem", 28, MDEREF_HV_vivify_rv2hv_helem },
        { "MDEREF_HV_padhv_helem", 21, MDEREF_HV_padhv_helem },
        { "MDEREF_HV_gvhv_helem", 20, MDEREF_HV_gvhv_helem },
        { "MDEREF_ACTION_MASK", 18, MDEREF_ACTION_MASK },
        { "MDEREF_INDEX_none", 17, MDEREF_INDEX_none },
        { "MDEREF_INDEX_const", 18, MDEREF_INDEX_const },
        { "MDEREF_INDEX_padsv", 18, MDEREF_INDEX_padsv },
        { "MDEREF_INDEX_gvsv", 17, MDEREF_INDEX_gvsv },
        { "MDEREF_INDEX_MASK", 17, MDEREF_INDEX_MASK },
        { "MDEREF_FLAG_last", 16, MDEREF_FLAG_last },
        { "MDEREF_MASK", 11, MDEREF_MASK },
        { "MDEREF_SHIFT", 12, MDEREF_SHIFT },
        { "OPpLVREF_SV", 11, OPpLVREF_SV },
        { "OPpARG1_MASK", 12, OPpARG1_MASK },
        { "OPpCOREARGS_DEREF1", 18, OPpCOREARGS_DEREF1 },
        { "OPpENTERSUB_INARGS", 18, OPpENTERSUB_INARGS },
        { "OPpSORT_NUMERIC", 15, OPpSORT_NUMERIC },
        { "OPpTRANS_FROM_UTF", 17, OPpTRANS_FROM_UTF },
        { "OPpCONST_NOVER", 14, OPpCONST_NOVER },
        { "OPpCOREARGS_DEREF2", 18, OPpCOREARGS_DEREF2 },
        { "OPpEVAL_HAS_HH", 14, OPpEVAL_HAS_HH },
        { "OPpFT_ACCESS", 12, OPpFT_ACCESS },
        { "OPpGREP_LEX", 11, OPpGREP_LEX },
        { "OPpHINT_STRICT_REFS", 19, OPpHINT_STRICT_REFS },
        { "OPpSORT_INTEGER", 15, OPpSORT_INTEGER },
        { "OPpTRANS_TO_UTF", 15, OPpTRANS_TO_UTF },
        { "OPpARG2_MASK", 12, OPpARG2_MASK },
        { "OPpCONST_SHORTCIRCUIT", 21, OPpCONST_SHORTCIRCUIT },
        { "OPpDONT_INIT_GV", 15, OPpDONT_INIT_GV },
        { "OPpENTERSUB_HASTARG", 19, OPpENTERSUB_HASTARG },
        { "OPpEVAL_UNICODE", 15, OPpEVAL_UNICODE },
        { "OPpFT_STACKED", 13, OPpFT_STACKED },
        { "OPpITER_REVERSED", 16, OPpITER_REVERSED },
        { "OPpLVREF_ELEM", 13, OPpLVREF_ELEM },
        { "OPpSLICEWARNING", 15, OPpSLICEWARNING },
        { "OPpSORT_REVERSE", 15, OPpSORT_REVERSE },
        { "OPpTRANS_IDENTICAL", 18, OPpTRANS_IDENTICAL },
        { "OPpARG3_MASK", 12, OPpARG3_MASK },
        { "OPpPADRANGE_COUNTSHIFT", 22, OPpPADRANGE_COUNTSHIFT },
        { "OPpCONST_STRICT", 15, OPpCONST_STRICT },
        { "OPpENTERSUB_AMPER", 17, OPpENTERSUB_AMPER },
        { "OPpEVAL_BYTES", 13, OPpEVAL_BYTES },
        { "OPpFT_STACKING", 14, OPpFT_STACKING },
        { "OPpITER_DEF", 11, OPpITER_DEF },
        { "OPpLVREF_ITER", 13, OPpLVREF_ITER },
        { "OPpMAYBE_LVSUB", 14, OPpMAYBE_LVSUB },
        { "OPpREVERSE_INPLACE", 18, OPpREVERSE_INPLACE },
        { "OPpSORT_INPLACE", 15, OPpSORT_INPLACE },
        { "OPpTRANS_SQUASH", 15, OPpTRANS_SQUASH },
        { "OPpARG4_MASK", 12, OPpARG4_MASK },
        { "OPpCONST_ENTERED", 16, OPpCONST_ENTERED },
        { "OPpDEREF_AV", 11, OPpDEREF_AV },
        { "OPpEVAL_COPHH", 13, OPpEVAL_COPHH },
        { "OPpFT_AFTER_t", 13, OPpFT_AFTER_t },
        { "OPpLVREF_AV", 11, OPpLVREF_AV },
        { "OPpMAYBE_TRUEBOOL", 17, OPpMAYBE_TRUEBOOL },
        { "OPpMULTIDEREF_EXISTS", 20, OPpMULTIDEREF_EXISTS },
        { "OPpOPEN_IN_RAW", 14, OPpOPEN_IN_RAW },
        { "OPpSORT_DESCEND", 15, OPpSORT_DESCEND },
        { "OPpSUBSTR_REPL_FIRST", 20, OPpSUBSTR_REPL_FIRST },
        { "OPpTARGET_MY", 12, OPpTARGET_MY },
        { "OPpDEREF_HV", 11, OPpDEREF_HV },
        { "OPpEARLY_CV", 11, OPpEARLY_CV },
        { "OPpEVAL_RE_REPARSING", 20, OPpEVAL_RE_REPARSING },
        { "OPpHUSH_VMSISH", 14, OPpHUSH_VMSISH },
        { "OPpLVREF_HV", 11, OPpLVREF_HV },
        { "OPpMAY_RETURN_CONSTANT", 22, OPpMAY_RETURN_CONSTANT },
        { "OPpMULTIDEREF_DELETE", 20, OPpMULTIDEREF_DELETE },
        { "OPpOPEN_IN_CRLF", 15, OPpOPEN_IN_CRLF },
        { "OPpSORT_QSORT", 13, OPpSORT_QSORT },
        { "OPpTRANS_COMPLEMENT", 19, OPpTRANS_COMPLEMENT },
        { "OPpTRUEBOOL", 11, OPpTRUEBOOL },
        { "OPpDEREF", 8, OPpDEREF },
        { "OPpDEREF_SV", 11, OPpDEREF_SV },
        { "OPpLVREF_CV", 11, OPpLVREF_CV },
        { "OPpLVREF_TYPE", 13, OPpLVREF_TYPE },
        { "OPpALLOW_FAKE", 13, OPpALLOW_FAKE },
        { "OPpASSIGN_BACKWARDS", 19, OPpASSIGN_BACKWARDS },
        { "OPpASSIGN_COMMON", 16, OPpASSIGN_COMMON },
        { "OPpCONST_BARE", 13, OPpCONST_BARE },
        { "OPpCOREARGS_SCALARMOD", 21, OPpCOREARGS_SCALARMOD },
        { "OPpENTERSUB_DB", 14, OPpENTERSUB_DB },
        { "OPpEXISTS_SUB", 13, OPpEXISTS_SUB },
        { "OPpFLIP_LINENUM", 15, OPpFLIP_LINENUM },
        { "OPpLIST_GUESSED", 15, OPpLIST_GUESSED },
        { "OPpLVAL_DEFER", 13, OPpLVAL_DEFER },
        { "OPpOPEN_OUT_RAW", 15, OPpOPEN_OUT_RAW },
        { "OPpOUR_INTRO", 12, OPpOUR_INTRO },
        { "OPpPAD_STATE", 12, OPpPAD_STATE },
        { "OPpREFCOUNTED", 13, OPpREFCOUNTED },
        { "OPpREPEAT_DOLIST", 16, OPpREPEAT_DOLIST },
        { "OPpRUNTIME", 10, OPpRUNTIME },
        { "OPpSLICE", 8, OPpSLICE },
        { "OPpSORT_STABLE", 14, OPpSORT_STABLE },
        { "OPpTRANS_GROWS", 14, OPpTRANS_GROWS },
        { "OPpPADRANGE_COUNTMASK", 21, OPpPADRANGE_COUNTMASK },
        { "OPpASSIGN_CV_TO_GV", 18, OPpASSIGN_CV_TO_GV },
        { "OPpCOREARGS_PUSHMARK", 20, OPpCOREARGS_PUSHMARK },
        { "OPpENTERSUB_NOPAREN", 19, OPpENTERSUB_NOPAREN },
        { "OPpLVALUE", 9, OPpLVALUE },
        { "OPpLVAL_INTRO", 13, OPpLVAL_INTRO },
        { "OPpOFFBYONE", 11, OPpOFFBYONE },
        { "OPpOPEN_OUT_CRLF", 16, OPpOPEN_OUT_CRLF },
        { "OPpPV_IS_UTF8", 13, OPpPV_IS_UTF8 },
        { "OPpSPLIT_IMPLIM", 15, OPpSPLIT_IMPLIM },
        { "OPpTRANS_DELETE", 15, OPpTRANS_DELETE },
        { "RXf_PMf_STD_PMMOD_SHIFT", 23, RXf_PMf_STD_PMMOD_SHIFT },
        { "RXf_PMf_MULTILINE", 17, RXf_PMf_MULTILINE },
        { "RXf_PMf_SINGLELINE", 18, RXf_PMf_SINGLELINE },
        { "RXf_PMf_FOLD", 12, RXf_PMf_FOLD },
        { "RXf_PMf_EXTENDED", 16, RXf_PMf_EXTENDED },
        { "RXf_PMf_EXTENDED_MORE", 21, RXf_PMf_EXTENDED_MORE },
        { "RXf_PMf_NOCAPTURE", 17, RXf_PMf_NOCAPTURE },
        { "RXf_PMf_KEEPCOPY", 16, RXf_PMf_KEEPCOPY },
        { "RXf_PMf_CHARSET", 15, RXf_PMf_CHARSET },
        { "RXf_PMf_STRICT", 14, RXf_PMf_STRICT },
        { "RXf_PMf_SPLIT", 13, RXf_PMf_SPLIT },
        { "PMf_MULTILINE", 13, PMf_MULTILINE },
        { "PMf_SINGLELINE", 14, PMf_SINGLELINE },
        { "PMf_FOLD", 8, PMf_FOLD },
        { "PMf_EXTENDED", 12, PMf_EXTENDED },
        { "PMf_EXTENDED_MORE", 17, PMf_EXTENDED_MORE },
        { "PMf_NOCAPTURE", 13, PMf_NOCAPTURE },
        { "PMf_KEEPCOPY", 12, PMf_KEEPCOPY },
        { "PMf_CHARSET", 11, PMf_CHARSET },
        { "PMf_STRICT", 10, PMf_STRICT },
        { "PMf_SPLIT", 9, PMf_SPLIT },
        { "PADNAMEt_OUTER", 14, PADNAMEt_OUTER },
        { "PADNAMEt_STATE", 14, PADNAMEt_STATE },
        { "PADNAMEt_LVALUE", 15, PADNAMEt_LVALUE },
        { "PADNAMEt_TYPED", 14, PADNAMEt_TYPED },
        { "PADNAMEt_OUR", 12, PADNAMEt_OUR },
        { "RXf_NO_INPLACE_SUBST", 20, RXf_NO_INPLACE_SUBST },
        { "RXf_EVAL_SEEN", 13, RXf_EVAL_SEEN },
        { "RXf_UNBOUNDED_QUANTIFIER_SEEN", 29, RXf_UNBOUNDED_QUANTIFIER_SEEN },
        { "RXf_CHECK_ALL", 13, RXf_CHECK_ALL },
        { "RXf_MATCH_UTF8", 14, RXf_MATCH_UTF8 },
        { "RXf_USE_INTUIT_NOML", 19, RXf_USE_INTUIT_NOML },
        { "RXf_USE_INTUIT_ML", 17, RXf_USE_INTUIT_ML },
        { "RXf_INTUIT_TAIL", 15, RXf_INTUIT_TAIL },
        { "RXf_IS_ANCHORED", 15, RXf_IS_ANCHORED },
        { "RXf_COPY_DONE", 13, RXf_COPY_DONE },
        { "RXf_TAINTED_SEEN", 16, RXf_TAINTED_SEEN },
        { "RXf_TAINTED", 11, RXf_TAINTED },
        { "RXf_START_ONLY", 14, RXf_START_ONLY },
        { "RXf_SKIPWHITE", 13, RXf_SKIPWHITE },
        { "RXf_WHITE", 9, RXf_WHITE },
        { "RXf_NULL", 8, RXf_NULL },
        { "SVf_IOK", 7, SVf_IOK },
        { "SVf_NOK", 7, SVf_NOK },
        { "SVf_POK", 7, SVf_POK },
        { "SVf_ROK", 7, SVf_ROK },
        { "SVp_IOK", 7, SVp_IOK },
        { "SVp_NOK", 7, SVp_NOK },
        { "SVp_POK", 7, SVp_POK },
        { "SVp_SCREAM", 10, SVp_SCREAM },
        { "SVf_PROTECT", 11, SVf_PROTECT },
        { "SVs_PADTMP", 10, SVs_PADTMP },
        { "SVs_PADSTALE", 12, SVs_PADSTALE },
        { "SVs_TEMP", 8, SVs_TEMP },
        { "SVs_OBJECT", 10, SVs_OBJECT },
        { "SVs_GMG", 7, SVs_GMG },
        { "SVs_SMG", 7, SVs_SMG },
        { "SVs_RMG", 7, SVs_RMG },
        { "SVf_FAKE", 8, SVf_FAKE },
        { "SVf_OOK", 7, SVf_OOK },
        { "SVf_BREAK", 9, SVf_BREAK },
        { "SVf_READONLY", 12, SVf_READONLY },
        { "SVf_AMAGIC", 10, SVf_AMAGIC },
        { "SVf_IsCOW", 9, SVf_IsCOW },
        { "SVf_UTF8", 8, SVf_UTF8 },
        { "SVf_IVisUV", 10, SVf_IVisUV },
        { "SVs_PADMY", 9, SVs_PADMY },
        { NULL, 0, 0 } };
	const struct uv_s *value_for_uv = values_for_uv;
        while (value_for_iv->name) {
	    he = _add_symbol(aTHX_  symbol_table, value_for_iv->name,
				     value_for_iv->namelen, newSViv(value_for_iv->value));
	    av_push(push, newSVhek(HeKEY_hek(he)));
            ++value_for_iv;
	}
        while (value_for_uv->name) {
	    he = _add_symbol(aTHX_  symbol_table, value_for_uv->name,
				     value_for_uv->namelen, newSVuv(value_for_uv->value));
	    av_push(push, newSVhek(HeKEY_hek(he)));
            ++value_for_uv;
	}
	if (C_ARRAY_LENGTH(values_for_notfound) > 1) {
#ifndef SYMBIAN
	    HV *const _missing = get_missing_hash(aTHX);
#endif
	    const struct notfound_s *value_for_notfound = values_for_notfound;
	    do {

		/* Need to add prototypes, else parsing will vary by platform.  */
		HE *he = (HE*) hv_common_key_len(symbol_table,
						 value_for_notfound->name,
						 value_for_notfound->namelen,
						 HV_FETCH_LVALUE, NULL, 0);
		SV *sv;
#ifndef SYMBIAN
		HEK *hek;
#endif
		if (!he) {
		    Perl_croak(aTHX_ 
			       "Couldn't add key '%s' to %%B::",
			       value_for_notfound->name);
		}
		sv = HeVAL(he);
		if (!SvOK(sv) && SvTYPE(sv) != SVt_PVGV) {
		    /* Nothing was here before, so mark a prototype of ""  */
		    sv_setpvn(sv, "", 0);
		} else if (SvPOK(sv) && SvCUR(sv) == 0) {
		    /* There is already a prototype of "" - do nothing  */
		} else {
		    /* Someone has been here before us - have to make a real
		       typeglob.  */
		    /* It turns out to be incredibly hard to deal with all the
		       corner cases of sub foo (); and reporting errors correctly,
		       so lets cheat a bit.  Start with a constant subroutine  */
		    CV *cv = newCONSTSUB(symbol_table,
					 value_for_notfound->name,
					 &PL_sv_yes);
		    /* and then turn it into a non constant declaration only.  */
		    SvREFCNT_dec(CvXSUBANY(cv).any_ptr);
		    CvCONST_off(cv);
		    CvXSUB(cv) = NULL;
		    CvXSUBANY(cv).any_ptr = NULL;
		}
#ifndef SYMBIAN
		hek = HeKEY_hek(he);
		if (!hv_common(_missing, NULL, HEK_KEY(hek),
 			       HEK_LEN(hek), HEK_FLAGS(hek), HV_FETCH_ISSTORE,
			       &PL_sv_yes, HEK_HASH(hek)))
		    Perl_croak(aTHX_  "Couldn't add key '%s' to missing_hash",
			       value_for_notfound->name);
#endif
		av_push(push, newSVhek(hek));
	    } while ((++value_for_notfound)->name);
	}
    /* As we've been creating subroutines, we better invalidate any cached
       methods  */
    mro_method_changed_in(symbol_table);
  }

#line 788 "B.xs"
{
    CV *cv;
    const char *file = __FILE__;
    SV *sv;
    MY_CXT_INIT;
    B_init_my_cxt(aTHX_ &(MY_CXT));
    cv = newXS("B::init_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, initav);
    cv = newXS("B::check_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, checkav_save);
    cv = newXS("B::unitcheck_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, unitcheckav_save);
    cv = newXS("B::begin_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, beginav_save);
    cv = newXS("B::end_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, endav);
    cv = newXS("B::main_cv", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, main_cv);
    cv = newXS("B::inc_gv", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, incgv);
    cv = newXS("B::defstash", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, defstash);
    cv = newXS("B::curstash", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, curstash);
#ifdef PL_formfeed
    cv = newXS("B::formfeed", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, formfeed);
#endif
#ifdef USE_ITHREADS
    cv = newXS("B::regex_padav", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, regex_padav);
#endif
    cv = newXS("B::warnhook", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, warnhook);
    cv = newXS("B::diehook", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, diehook);
    sv = get_sv("B::OP::does_parent", GV_ADDMULTI);
#ifdef PERL_OP_PARENT
    sv_setsv(sv, &PL_sv_yes);
#else
    sv_setsv(sv, &PL_sv_no);
#endif
}

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#line 2421 "B.xs"
{
    /* Uses less memory than an ALIAS.  */
    GV *gv = gv_fetchpvs("B::PADNAME::TYPE", 1, SVt_PVGV);
    sv_setsv((SV *)gv_fetchpvs("B::PADNAME::SvSTASH",1,SVt_PVGV),(SV *)gv);
    sv_setsv((SV *)gv_fetchpvs("B::PADNAME::PROTOCV",1,SVt_PVGV),(SV *)gv);
    sv_setsv((SV *)gv_fetchpvs("B::PADNAME::PVX",1,SVt_PVGV),
	     (SV *)gv_fetchpvs("B::PADNAME::PV" ,1,SVt_PVGV));
    sv_setsv((SV *)gv_fetchpvs("B::PADNAME::PARENT_PAD_INDEX" ,1,SVt_PVGV),
	     (SV *)gv_fetchpvs("B::PADNAME::COP_SEQ_RANGE_LOW",1,
				SVt_PVGV));
    sv_setsv((SV *)gv_fetchpvs("B::PADNAME::PARENT_FAKELEX_FLAGS",1,
				SVt_PVGV),
	     (SV *)gv_fetchpvs("B::PADNAME::COP_SEQ_RANGE_HIGH"  ,1,
				SVt_PVGV));
}

#line 4656 "B.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

